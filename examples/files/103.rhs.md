// My header
#include "e_Project.h"

// boost
#include <boost/regex.hpp>

// STL
#include <algorithm>

// Fmt
#include <filesystem>
#include <fmt/format.h>
#include <system_error>
#include <unordered_map>

// spdlog
#include <spdlog/spdlog.h>

#include "InventoryCollectionsStorage/com_InvCollectionUniqueId.h"
#include "InventoryCollectionsStorage/e_ContainerInfo.h"
#include "InventoryCollectionsStorage/e_Group.h"
#include "Stream.h"
#include "im_GlobalLogParams.h"
#include "u_Array.h"
#include "u_EnumParsers.h"
#include "u_FilesystemUtils.h"
#include "u_Overloaded.h"


#include "com_AggregateKey.h"
#include "com_ProjectId.h"
#include "com_ProjectSavingParams.h"
#include "com_TreeSettings.h"
#include "com_User.h"
#include "com_VirtualRole.h"


#include "com_VirtualUser.h"

#include "e_BuildTopDownAlternative.h"
#include "e_PredictionOverridesSaveLoadUtils.h"
#include "e_SubstitutionRulesStorage.h"
#include "u_EraseByIndices.h"
#include "u_Strings.h"


// License
#ifndef STREAMLINE_SERVER
    #include "cli_LicenseUtils.h"
#endif
#ifdef STREAMLINE_SERVER
    #include "com_UserInfo.h"
    #include "com_UsersInfoProvider.h"
    #include "sv_FileSystemManager.h"
#endif

// Library
#include "i_Paths.h"
#include "u_AdminPermissionsUtils.h"
#include "u_FilesystemUtils.h"
#include "u_Lazy.h"
#include "u_Printf.h"
#include "u_UniqueCounter.h"
#include "u_Uuid.h"


// Calendar
#include "e_DecidingDatePredictor.h"

// Streams
#include "MiniZipPort.h"
#include "u_Streams.h"

// Import
#include "e_ArrivalObj.h"
#include "e_BackorderObj.h"
#include "im_CompiledSubstitutions.h"
#include "im_DateConv.h"
#include "im_Defines.h"

// Project-local
#include "com_ProjectStats.h"
#include "d_Paths.h"
#include "e_BomsWithSubstitutions.h"
#include "e_Model.h"
#include "e_ReplacementDic.h"
#include "i_Async.h"
#include "i_LicenseInfoSource.h"
#include "u_ChunkMap.h"
#include "u_ProjectFile.h"

///@todo [source org] MapCache is reasonably here, but declared in sv_
#include "e_AccessCache.h"
#include "e_AutoColEnabler.h"
#include "sv_FilteredMap.h"


/// @todo [source organization] Engine should not rely on server:
///    MultiKpi
#include "sv_Inventory.h"

/// @todo [source organization] Client here
#include "cli_VersionInfo.h"

// again to prevent VMT glitches
#include "e_NoteUtils.h"

#include "tinyxml2.h"
#include <fmt/xchar.h>

#include "com_ImportErrors.h"
#include "com_TopDownApproach.h"
#include "u_LogicErrorEx.h"


#include "com_ProjectDates.h"

#include "e_FeatureManager.h"

#ifdef _WIN32
    #include "winbase.h"
#endif

#include "InTransitionStorage/e_ArrivalStorage.h"
#include "InTransitionStorage/e_BackorderStorage.h"


#include "e_SuppliersStorage.h"

#include "e_SubstitutionsStorageManager.h"

#include "sv_AnalyticsSettings.h"  // used
#include "u_ParseSeparatedValues.h"


// Check for file interoperability
// If find a failing machine → think what to do
static_assert(
    std::numeric_limits<float>::is_iec559,
    "File interoperability is not implemented for non-ISO machines"
);
static_assert(
    std::numeric_limits<double>::is_iec559,
    "File interoperability is not implemented for non-ISO machines"
);

namespace dbg {
    // Set to empty to disable debug of a single item
    constexpr std::wstring_view ITEM{};

    // Trigger warning if debug on
    [[maybe_unused]] constexpr uint8_t DEBUG_WARNING_ITEM = (!dbg::ITEM.empty()) * 1000;
}

using namespace std::string_view_literals;

// #define DUMP_LOAD

#ifdef DUMP_LOAD
    #define LOAD_MSG(x) std::cerr << x << std::endl;
#else
    #define LOAD_MSG(x)
#endif

bool wantWriteUnsafely = false;
const ArchiveInfo ArchiveInfo::DFLT;


#define USE_V1_FORMAT


// Extern templates
template class std::unique_ptr<DoubleMap>;
template class std::weak_ptr<const SalesCulture>;

template class std::unique_ptr<im::Importer>;
template class std::weak_ptr<SalesEntry>;

const ProjectSettings ProjectSettings::DFLT;

NoPromotions NoPromotions::INST;

///// ArchivedPointsData //////////////////////

void fr::ArchivedPointsData::rebuild(const std::vector<RealPoint>& aRealPoints)
{
    const size_t sz = aRealPoints.size();
    reserve(sz);
    for (size_t index = 0u; index < sz; ++index) {
        if (aRealPoints.at(index).part != NO_ARCHIVE) {
            add(index);
        }
    }
}

///// Cultures /////////////////////////////////////////////////////////////////


void SalesProject::Cultures::cleanup()
{
    size_t n = 0;
    FOR_S(i, 0, list.size()) {
        std::weak_ptr<const SalesCulture>& culture = list[i];
        if (!culture.expired()) {
            if (i != n)
                list[n] = culture;
            ++n;
        }
    }
    list.resize(n);
}

void SalesProject::Cultures::enumerate()
{
    cleanup();
    FOR_S(i, 0, list.size()) {
        std::shared_ptr<const SalesCulture> culture = list[i].lock();
        if (!culture)
            throw UNEXPECTED_EXCEPTION("Culture is missing, strange things happen");
        culture->temp1 = i;
    }
}

std::shared_ptr<const SalesCulture> SalesProject::Cultures::find(const holi::Culture& x)
{
    for (auto& v : list) {
        std::shared_ptr<const SalesCulture> culture = v.lock();
        if (culture && *culture == x)
            return culture;
    }
    return nullptr;
}

std::shared_ptr<const SalesCulture> SalesProject::Cultures::add(const holi::Culture& x)
{
    std::shared_ptr<const SalesCulture> r = find(x);
    if (!r) {
        r = std::make_shared<const SalesCulture>(x);
        list.push_back(r);
    }
    return r;
}

std::shared_ptr<const SalesCulture> SalesProject::Cultures::add(const holi::Culture&& x)
{
    std::shared_ptr<const SalesCulture> r = find(x);
    if (!r) {
        r = std::make_shared<const SalesCulture>(x);
        list.push_back(r);
    }
    return r;
}

///// SalesProject /////////////////////////////////////////////////////////////


SalesProject::SalesProject()
    : fFeatureManager(std::make_unique<FeatureManager>()),
      fMap(std::make_shared<DoubleMap>(*this)),
      alertsData(*this),
      fInventoryCollector(&sets.containerInfo)
{
    fAvailableMainTabs.write<Flags<TabMasks>>([](Flags<TabMasks>* obj) mutable {
        *obj |= Flags<TabMasks>::allRaisedBits().remove(TabMasks::INVENTORY_OPTIMIZATION);
    });
}

SalesProject::~SalesProject() = default;

bool SalesProject::extendMainStorage(size_t anNewPoints)
{
    if (anNewPoints <= nRealPoints())
        return false;
    extendArray(fRealPoints, anNewPoints, RealPoint(dt::Date::ZERO, 1.0));
    return true;
}

bool SalesProject::extendStorage(size_t anNewPoints, const InventoryPoint& aExtendValue)
{
    if (!extendMainStorage(anNewPoints))
        return false;

    fMap->extendStorage(anNewPoints, aExtendValue);
    return true;
}

void SalesProject::setPoint(size_t aIndex, const dt::Date& aDate, float aPart)
{
    if (aIndex < nRealPoints()) {
        fRealPoints[aIndex] = RealPoint(aDate, aPart);
        return;
    }

    throw std::out_of_range(
        fmt::format("[setPoint] Index out of bounds ({}/{})", aIndex, nRealPoints())
    );
}

void SalesProject::setOnlyPointPart(size_t aIndex, float aPart)
{
    if (aIndex < nRealPoints()) {
        fRealPoints[aIndex].part = aPart;
        return;
    }
    throw std::out_of_range(
        fmt::format("[setOnlyPointPart] Index out of bounds ({}/{})", aIndex, nRealPoints())
    );
}

SafeVector<SalesChannel*> SalesProject::detectClones(CloneMode mode)
{
    return fMap->detectClones(mode);
}

std::weak_ptr<SalesEntry> SalesProject::atEx(
    const Entity& aEntity, const RefStrings& aCats, const RefStrings& aLocationCats,
    bool& rWasNewItemCreated, bool& rWasNewLocationCreated, bool& rWasNewEntityCreated
)
{
    DoubleMap::Item* item = nullptr;
    DoubleMap::Location* location = nullptr;
    std::shared_ptr<SalesEntry> r = fMap->atEx(
        aEntity, aCats, aLocationCats, item, location, rWasNewItemCreated, rWasNewLocationCreated,
        rWasNewEntityCreated
    );
    // r.init(*this, *item, *location, aEntity);
    return r;
}

SalesChannel& SalesProject::channelAt(
    const ChannelId& channel, const RefStrings& itemCats, const RefStrings& locationCats,
    const RefStrings& channelCats, bool& rWasNewItemCreated, bool& rWasNewLocationCreated,
    bool& rWasNewEntityCreated, bool& rWasNewChannelCreated
)
{
    DoubleMap::Item* item;
    DoubleMap::Location* location;

    SalesChannel& r = fMap->channelAt(
        channel, itemCats, locationCats, channelCats, item, location, rWasNewItemCreated,
        rWasNewLocationCreated, rWasNewEntityCreated, rWasNewChannelCreated
    );
    return r;
}

namespace {
    template <typename Container>
        requires typetrait::is_iterable<Container>
    auto findByName(Container& container, std::wstring_view name)
    {
        return std::find_if(container.begin(), container.end(), [&name](const auto& item) {
            return name == item.name;
        });
    }

    /// @attention invalidates @a wholeIt iterator
    void renameWhole(
        bom::WholeMap& wholes, bom::WholeMap::iterator wholeIt, std::wstring_view newName
    )
    {
        auto node = wholes.extract(wholeIt);
        node.key() = newName;
        wholes.insert(std::move(node));
    }

    void renamePart(
        bom::Bom& wholes, bom::WholeMap::const_iterator inverseBomPartIt, std::wstring_view newName
    )
    {
        const auto& [oldName, byLocation] = *inverseBomPartIt;

        // traverse all wholes, that use this part
        // rename this part in all parts vectors
        for (auto& [location, partInfo] : byLocation) {
            for (auto& whole : partInfo.parts) {
                auto* wholeInfo = wholes.find(whole.name, location);
                for (auto& part : wholeInfo->parts) {
                    if (part.name == oldName) {
                        part.name = newName;
                    }
                }
            }
        }
    }
}  // namespace

void SalesProject::renameBomItem(const std::wstring& oldItem, const std::wstring& newItem)
{
    bool bomsAffected = false;

    if (auto it = fBom.wholes.find(oldItem); it != fBom.wholes.end()) {
        // whole name changed
        renameWhole(fBom.wholes, it, newItem);
        bomsAffected = true;
    }

    if (auto it = fInvBom.wholes.find(oldItem); it != fInvBom.wholes.end()) {
        // part name changed
        renamePart(fBom, it, newItem);
        bomsAffected = true;
    }

    if (bomsAffected) {
        buildTopoOrder();
    }
}

namespace {
    using BomIterator = bom::WholeMap::iterator;

    /// @brief Merge bom parts:
    ///        if some old and new parts are used for wholes on same location, we merge them and add
    ///        quantities
    ///
    void mergeBomParts(BomIterator oldPartIt, BomIterator newPartIt, bom::Bom& boms)
    {
        // new item is also a part, so now there can be some wholes in which this part will be
        // multiple times we have to aggregate them into single usage of part
        for (auto& [location, partInfo] : oldPartIt->second) {
            auto it = newPartIt->second.find(location);

            if (it == newPartIt->second.end()) {
                // new part is not used for manufacturing on this location:
                // skip and rename later
                continue;
            }

            const auto& wholesOfOldPart = partInfo.parts;
            const auto& wholesOfNewPart = it->second.parts;

            for (const auto& whole : wholesOfOldPart) {
                if (findByName(wholesOfNewPart, whole.name) == wholesOfNewPart.end()) {
                    continue;
                }

                // old part and new part are both parts of this whole on this location
                auto& partsOfWhole = boms.find(whole.name, location)->parts;

                auto& newPart = *findByName(partsOfWhole, newPartIt->first);
                auto oldItemIt = findByName(partsOfWhole, oldPartIt->first);

                // add old part to new part in this parts of this whole
                newPart.qty += oldItemIt->qty;

                // remove old part from parts of this whole
                partsOfWhole.erase(oldItemIt);
            }
        }
    }

    /// @return true if @a bom was changed
    bool deleteBomItem(bom::Bom& bom, const bom::Bom& invBom, const std::wstring& item)
    {
        bool bomsAffected = (bom.wholes.erase(item) == 1);

        if (auto itPart = invBom.wholes.find(item); itPart != invBom.wholes.end()) {
            // part deleted
            // traverse all wholes, that use this part
            // delete this part in all parts vectors
            for (const auto& [location, partInfo] : itPart->second) {
                for (const auto& whole : partInfo.parts) {
                    auto* bomWhole = bom.find(whole.name, location);
                    std::erase_if(bomWhole->parts, [&item](const bom::Part& part) {
                        return part.name == item;
                    });
                }
            }
            return true;
        }

        return bomsAffected;
    }

}  // namespace

void SalesProject::mergeBomItem(const std::wstring& oldItem, const std::wstring& newItem)
{
    auto oldWholeIt = fBom.wholes.find(oldItem);
    auto oldPartIt = fInvBom.wholes.find(oldItem);
    auto newWholeIt = fBom.wholes.find(newItem);
    auto newPartIt = fInvBom.wholes.find(newItem);

    if (oldWholeIt == fBom.wholes.end() && oldPartIt == fInvBom.wholes.end()) {
        // merged item not in bom, nothing was changed
        return;
    }

    if (newWholeIt == fBom.wholes.end() && newPartIt == fInvBom.wholes.end()) {
        // new item not in bom, so just rename old item
        renameBomItem(oldItem, newItem);
        return;
    }

    if (oldPartIt != fInvBom.wholes.end()) {
        // old item is part
        if (newPartIt != fInvBom.wholes.end()) {
            // new item is also a part, merge
            mergeBomParts(oldPartIt, newPartIt, fBom);
        }
        // rename part in wholes
        renamePart(fBom, oldPartIt, newItem);
    }

    // just delete oldItem, because now it will have bom of newItem
    ::deleteBomItem(fBom, fInvBom, oldItem);

    buildTopoOrder();
}

void SalesProject::deleteBomItem(const std::wstring& item)
{
    if (::deleteBomItem(fBom, fInvBom, item)) {
        buildTopoOrder();
    }
}

EcArray<size_t, DashTileType> SalesProject::calculatePlanningItems() const
{
    EcArray<size_t, DashTileType> r(FillArray::INST, 0);

    const uint16_t costOfCapital = setsC().kpi.costOfCapital;
    KpiResult kr(costOfCapital);

    static constexpr auto requiredKPIs
        = KPIsFlag::MISCELLANEOUS_KPIS | KPIsFlag::ACTUAL_YEARLY_INVENTORY_STATS;

    /// @todo [bad] An entire project traverse to count
    /// planning items, is there any lighter solution?
    for (const auto& entry : allEntries()) {
        getEntryKpis(entry, kr, requiredKPIs);

        FOR_EC_FULL(type, DashTileType) {
            const auto forecastColType = DashboardSettings::fgToForecastColClass(type);
            if (isDashboardValueFinite(forecastColType, entry, kr))
                ++r[type];
        }
    }

    return r;
}

size_t SalesProject::maxCultureSize() const
{
    const auto zeroOrSize = [](auto cult) { return cult ? cult->size() : 0; };
    const auto maxSizeComp = [&zeroOrSize](const auto& lhs, const auto& rhs) {
        return zeroOrSize(lhs.lock()) < zeroOrSize(rhs.lock());
    };

    auto it = std::max_element(fCultures.list.begin(), fCultures.list.end(), maxSizeComp);
    if (it != fCultures.list.end()) {
        return zeroOrSize(it->lock());
    }
    return 0;
}

//
//
// The Location is Dedicated DC when:
// 1) Items from other locations refer to it
// 2) No items from that Location refer to other locations
//
void SalesProject::findDedicatedDistribCenters()
{
    std::unordered_set<DoubleMap::Location*> distribCenters;

    availableAsDcs.clear();

    for (auto& it : fMap->byLocation) {
        availableAsDcs.emplace(it.second.key());

        for (auto& it2 : it.second) {
            it2.second->location().isDedicatedDc = false;
            auto dc = it2.second->byEntryDistrib().entry.lock();
            if (dc)
                distribCenters.insert(&dc->location());
        }
    }


    for (auto& it : distribCenters) {
        auto& currentLocation = *it;

        currentLocation.isDedicatedDc = true;
        for (auto& it2 : currentLocation) {
            auto dc = it2.second->byEntryDistrib().entry.lock();
            if (dc) {
                currentLocation.isDedicatedDc = false;
                break;
            }
        }
    }

    for (auto& e : allEntries()) {
        auto dcLoc = e.byEntryDistrib().locCode.activeValue();
        if (!dcLoc.empty()) {
            if (e.byEntryDistrib().isExternal())
                availableAsDcs.emplace(dcLoc);
            //            availableAsDcs.erase(e.location().key());
        }
    }
}

SalesEntry& SalesProject::operator[](const Entity& aEntity)
{
    return *fMap->atEx(aEntity, NoStrings::INST, NoStrings::INST);
}

bool SalesProject::shrinkTo(size_t aNewSize)
{
    if (nRealPoints() <= aNewSize)
        return false;

    shrinkArray(fRealPoints, aNewSize);
    fMap->shrinkTo(aNewSize);

    precisionCache.value = PRECISION_UNCACHED;
    return true;
}

bool SalesProject::cutOffFutureInArchive()
{
    return fArchive.cutOffFuture(periodEnd(pCurrKnown().tInventory), lastPeriodDate());
}

void SalesProject::actualizeHistoricalOnHandStorage()
{
    dt::Date lastDate = actualDate();
    size_t lastPeriod = nRealPoints() - 1;
    dt::Date yearAgoPeriodDate = [this]() {
        auto r = lastPeriodDate();
        r.subtractMonths1(12);
        return r;
    }();

    /// replenish
    for (const auto& entry : allEntries()) {
        if (auto newOnHand = entry.onHand(lastPeriod); newOnHand.isSet()) {
            fHistoricalOnHandStorage.add(entry.entity(), lastDate, newOnHand.activeValue(0));
        }
    }

    /// check whether we have records that do not have a corresponding entity in the project
    /// and are older than a year from the last known date
    fHistoricalOnHandStorage.cutOffIrrelevant(yearAgoPeriodDate, *this);

    /// trim outdated records
    fHistoricalOnHandStorage.trim(yearAgoPeriodDate);
}

void SalesProject::replenishArchive()
{
    static constexpr auto requiredKPIs
        = KPIsFlag::MISCELLANEOUS_KPIS | KPIsFlag::ACTUAL_YEARLY_INVENTORY_STATS;
    // KPI's
    MultiKpi mkpi(setsC().kpi.costOfCapital, requiredKPIs);
    for (auto it = allChannels().begin(); it != allChannels().end(); ++it)
        mkpi.feed(*it);

    double purchaseValue = D_NAN;
    double expectedWriteOffs = D_NAN;
    for (auto it = allEntries().begin(); it != allEntries().end(); ++it) {
        if (it->invCache.isCached() && it->isCurrencySame()) {
            // Purchase Value
            /// @todo [transferResult] false here for isOptimizationReport?
            double itsPurchaseValue = shownPurchaseValueAsDouble(*it, IsIntersite::NO);
            if (isFinite(itsPurchaseValue) && it->isPurchaseEchelon()) {
                if (!isFinite(purchaseValue))
                    purchaseValue = 0;
                purchaseValue += itsPurchaseValue;
            }

            // Write-offs
            double price = it->characteristicPrice();
            WrappedInt itsExpectedWriteOffs = allPeriodsExpirations(*it, Archive::HORIZON);
            if (isFinite(price) && price != 0. && itsExpectedWriteOffs.isSet()) {
                if (!isFinite(expectedWriteOffs))
                    expectedWriteOffs = 0;
                expectedWriteOffs += price * itsExpectedWriteOffs.activeValue(0);
            }
        }
    }

    dt::Date currentPeriod = lastPeriodDate();
    size_t archiveSize = fArchive.size();
    if (!archiveSize) {  // empty archive -> add
        fArchive.add(actualDate()).setInfo(mkpi, purchaseValue, expectedWriteOffs);
    }
    else if (fArchive.lastDate() < currentPeriod) {  // last archive period precedes current -> add
        fArchive.add(currentPeriod).setInfo(mkpi, purchaseValue, expectedWriteOffs);
    }
    else {  // last archive period is current
        fArchive.lastInfo().setInfo(mkpi, purchaseValue, expectedWriteOffs);
    }
}

void SalesProject::deleteChannels(const ChannelFunctor<bool>& aWhich)
{
    fMap->deleteChannels(aWhich);
    areChannelsTrivialCache.reset();
    fMap->reindex();
    recache();
    recacheAvatarsChannels();
    dropWriteOffsCache();
    resizeVisibleCatsAndInfoFields();
}

namespace {

    bool pointLessDate(const RealPoint& x, const dt::Date& y)
    {
        return (x.date < y);
    }

    bool dateLessPoint(const dt::Date& x, const RealPoint& y)
    {
        return (x < y.date);
    }

}

void SalesProject::stealDataFrom(
    SalesProject& aOther, const dt::Date& aThresholdDate, size_t apMergeLo, size_t apMergeHi,
    im::AssortmentMode aAssortmentMode, spdlog::logger& rLog, bool hasWildcards,
    im::DateProgression aDateProgression, promo::StealDataPolicy promoStealDataPolicy
)
{
    // FOR FUTURE IMPLEMENTERS:
    // this = new (good)
    // aOther = old

    rLog.info("Project.stealDataFrom IN");

    // Nothing to merge?
    if (apMergeLo == 0) {
        aAssortmentMode = im::AssortmentMode::CHANNELS;
        rLog.info("Switched assortment to CHANNELS");

        // Reset ALL lost days
        rLog.info("resetHeadingLostDays CALL");
        resetHeadingLostDays();
        rLog.info("resetHeadingLostDays OK");
    }
    else {
        // Pick what to reset
        rLog.info("pick what to reset START");

        for (auto& [itemCode, item] : byItem()) {
            for (auto& [locCode, shEntry] : item) {
                SalesEntry& newEntry = *shEntry;
                SalesEntry* oldEntry = aOther.find(newEntry.entity());
                if (oldEntry) {  // Found
                    bool is0 = (oldEntry->realInventory[apMergeHi - 1].onHand.activeValue(1) <= 0);
                    if (!is0)
                        resetHeadingLostDays(newEntry);
                }
                else {  // Not found
                    resetHeadingLostDays(newEntry);
                }
            }
        }
        rLog.info("pick what to reset OK");
    }

    stealSimulationDataFrom(aOther);

    // Settings
    stealSettings(aOther.sets);
    plannedOrdersFilters = aOther.plannedOrdersFilters;

    /// @warning aOther.id() must not be moved! It used in Bg operations while projects merging
    fProjectIdStorage.set(aOther.id());
    modelId = std::move(aOther.modelId);
    rLog.info("Settings STEAL OK");

    setHorizon(aOther.horizon());
    rLog.info("Switch horizon OK");

    // Import manager
    imManager = std::move(aOther.imManager);
    rLog.info("im::Manager move OK");

    // Export order manager
    exportOrdersManager = std::move(aOther.exportOrdersManager);
    rLog.info("im::ExportOrdersManager move OK");

    exportReportsManager = std::move(aOther.exportReportsManager);
    rLog.info("im::ExportReportsManager move OK");

    // File names
    file = std::move(aOther.file);
    rLog.info("File move OK");

    // old data points [date -> index of a real point]
    using MDate = std::map<dt::Date, size_t>;
    MDate mOld;

    FOR_S(i, 0, aOther.nRealPoints()) {
        mOld[aOther.realPoints(i).date] = i;
    }

    // Create mapping new → old for real points
    const size_t nNewPoints = apMergeHi + nRealPoints();
    Array1d<size_t> realNew2Old(nNewPoints);
    realNew2Old.fill(NOT_FOUND);

    FOR_S(p, 0, apMergeHi) {
        realNew2Old[p] = p;
    }

    FOR_S(p, 0, nRealPoints()) {
        MDate::const_iterator it = mOld.find(realPoints(p).date);
        if (it != mOld.end()) {
            realNew2Old[apMergeHi + p] = it->second;
        }
    }

    rLog.info("Real points new->old mapping OK");

    //    std::cout << "realNew2Old: [";
    //    for (auto v : realNew2Old) {
    //        std::cout << " " << v;
    //    }
    //    std::cout << " ]" << std::endl;

    // Extend
    extendMainStorage(nNewPoints);
    rLog.info("Extend main storage OK");

    // Copy old points
    FOR_S(p, 0, apMergeHi)
        fRealPoints[p] = aOther.fRealPoints[p];
    rLog.info("Copy points OK");

    // Create mapping old → new (lower or equal) for real points
    Array1d<size_t> ignoreMap(aOther.nRealPoints());
    FOR_S(pOld, 0, apMergeHi)
        ignoreMap[pOld] = pOld;
    rLog.info("Build ignoreMap OK");

    auto ptrBegin = fRealPoints.cbegin();
    auto ptrMerge = ptrBegin + apMergeHi;
    auto ptrEnd = fRealPoints.cend();

    // New point that corresponds to 1st old point beyond range
    if (aOther.nRealPoints() != 0) {
        rLog.info("Update ignoreMap START");
        FOR_S(pOld, apMergeHi, aOther.nRealPoints()) {
            dt::Date oldDate = aOther.realPoints(pOld).date;
            auto whereFound = std::lower_bound(ptrMerge, ptrEnd, oldDate, pointLessDate);
            ignoreMap[pOld] = (whereFound == ptrEnd) ? nRealPoints() - 1
                            : (whereFound->date == oldDate)
                                ? whereFound - ptrBegin
                                : cu_minus<size_t>(whereFound - ptrBegin, 1u);
        }

        FOR_S(pNew, apMergeHi, nRealPoints()) {
            size_t pOld = realNew2Old[pNew];
            // Here we complement new project with period info from old project, based on new2old
            // mapping If old project has some viable data, steal it. Otherwise leave the period as
            // is
            if (pOld != NOT_FOUND) {
                fRealPoints[pNew].part = aOther.realPoints(pOld).part;
            }
        }

        // Regardless of anything, 0 → 0
        ignoreMap[0] = 0;
        rLog.info("Update ignoreMap OK");
    }

    predictDates(aDateProgression);

    SalesSyncData syncData(
        aThresholdDate, *this, aOther, realNew2Old, ignoreMap, apMergeLo, apMergeHi
    );

    // Steal
    fMap->stealDataFrom(*aOther.fMap, aAssortmentMode, syncData, hasWildcards);
    rLog.info("Main map steal data from OK");

    fBom.stealDataFrom(aOther.fBom);

    // Cultures
    fCultures = std::move(aOther.fCultures);
    rLog.info("Cultures move OK");
    // As movement can destroy some models, clean up!
    fCultures.cleanup();
    rLog.info("Cultures cleanup OK");

    // Archive
    fArchive = std::move(aOther.fArchive);
    rLog.info("Archive move OK");

    // Custom containers
    inventoryCollector().stealDataFrom(std::move(aOther.fInventoryCollector));
    rLog.info("Custom containers move OK");
    removeInvalidContainerOverrides();
    removeInvalidGroupOverrides();

    suppliersStorage().stealDataFrom(aOther.suppliersStorage(), *this);
    rLog.info("Custom suppliers move OK");

    // Report tabs
    invTabsData = std::move(aOther.invTabsData);
    rLog.info("invTabs move OK");

    optimizedInvTabsData = std::move(aOther.optimizedInvTabsData);
    rLog.info("optimizedTabs move OK");

    forecastTabsData = std::move(aOther.forecastTabsData);
    rLog.info("forecastTabs move OK");

    oldAccess = std::move(aOther.oldAccess);
    access = std::move(aOther.access);

    rLog.info("access move OK");
    rLog.info("accessManipulator move OK");

    intrinsicCache = std::move(aOther.intrinsicCache);
    rLog.info("intrinsicCache move OK");

    fProjectChangelog = std::move(aOther.fProjectChangelog);
    rLog.info("fProjectChangelog move OK");

    fAvailableMainTabs = std::move(aOther.fAvailableMainTabs);
    rLog.info("fAvailableMainTabs move OK");

    fForecastVersionsStorage = std::move(aOther.fForecastVersionsStorage);
    rLog.info("fAlternativeForecastsStorage move OK");

    fInTransitionStorageManager.stealDataFrom(aOther.fInTransitionStorageManager, *this);
    rLog.info("fInTransitionStorageManager steal data OK");

    fPromotionsStorage.stealDataFrom(
        aOther.promotionsStorage(), *this, syncData.thresholdDate, promoStealDataPolicy
    );
    rLog.info("Promotions Storage move OK");

    fHistoricalOnHandStorage = std::move(aOther.fHistoricalOnHandStorage);
    rLog.info("HistoricalOnHandStorage move OK");

    patterns = std::move(aOther.patterns);
    availablePatternId = aOther.availablePatternId;
    rLog.info("patterns move OK");

    tenantId = std::move(aOther.tenantId);
    fronteggEnvName = std::move(aOther.fronteggEnvName);

    usersSettings = std::move(aOther.usersSettings);

    fDashboardSettings = std::move(aOther.fDashboardSettings);

    rLog.info("Project.stealDataFrom OUT");

    // steal limit hit state if it's full reimport
    if (aOther.fLimitHitState.load().hasValue()) {
        fLimitHitState = std::move(aOther.fLimitHitState);
    }

    fIsForecastConstrained = aOther.fIsForecastConstrained;
    fIsConnector2 = aOther.fIsConnector2;

    rLog.info("Project.stealDataFrom OUT");
}

void SalesProject::stealSimulationDataFrom(SalesProject& aOther)
{
    isSimulationOn.store(aOther.isSimulationOn.load());

    if (isSimulationOn.load()) {
        baseCurrency = aOther.baseCurrency;

        // copy item info
        for (auto& v : byItem()) {
            auto it = aOther.byItem().find(v.first);
            if (it) {
                v.second.info = it->info;
            }

            // copy entry info
            for (auto& w : v.second) {
                SalesEntry& newEntry = *w.second;
                if (SalesEntry* oldEntry = aOther.find(newEntry.entity()); oldEntry) {
                    newEntry.entryInfo() = oldEntry->entryInfo();
                    newEntry.setByEntryDistrib(oldEntry->byEntryDistrib().locCode);
                    for (auto& [name, channel] : newEntry.channels) {
                        auto oldChannelIt = oldEntry->channels.findByName(name);
                        if (oldChannelIt != oldEntry->channels.end()) {
                            channel.simulationInfo = oldChannelIt->second.simulationInfo;
                        }
                    }

                    // steal batches
                    newEntry.expiration = std::move(oldEntry->expiration);
                }
            }
        }

        // steal location info
        for (auto& v : byLocation()) {
            auto it = aOther.byLocation().find(v.first);
            if (it) {
                v.second.info = std::move(it->info);
            }
        }
    }
}

void SalesProject::stealSettings(ProjectSettings& aOther)
{
    sets = std::move(aOther);
    if (importedOC.has_value()) {
        sets.resetOrderCycleUnit(*importedOC);
    }
}

void SalesProject::fixupOwnership()
{
    fMap->setOwner(*this);
    fInventoryCollector.setContainerSets(&sets.containerInfo);
}

size_t SalesProject::getPMerge(const dt::Date& aDate) const
{
    if (!aDate.isValid())
        return 0;
    size_t r = nRealPoints();
    while (r > 0 && realPoints(r - 1).date >= aDate) {
        --r;
    }
    return r;
}

namespace {

    ///
    /// \brief The ImportWatchdog class
    ///     Clears the project if smth goes wrong
    ///
    class ImportWatchdog
    {
    private:
        SalesProject& project;
        bool isEnabled = true;

    public:
        ImportWatchdog(SalesProject& aProject) : project(aProject) {}

        void disable() { isEnabled = false; }

        ~ImportWatchdog()
        {
            if (isEnabled) {
                project.clear();
            }
        }
    };
}  // namespace

ImportMetaInfo SalesProject::importFromScratch(std::unique_ptr<im::Importer>& aImporter)
{
    // for first import -- pass subst of NEW project
    return importFromScratch(
        aImporter, aImporter->detectNDates(dt::Date::ZERO), dt::Date::ZERO,
        substitutionsStorageManager()
    );
}

namespace {
    size_t getMaxNDates(const im::MultipleImporters& data)
    {
        auto maxNDates = data.front()->detectNDates(dt::Date::ZERO);
        for (const auto& importer : data)
            maxNDates = std::max(maxNDates, importer->detectNDates(dt::Date::ZERO));
        return maxNDates;
    }

}

ImportMetaInfo SalesProject::importFromScratch(im::MultipleImporters& data)
{
    return importFromScratch(
        data, getMaxNDates(data), dt::Date::ZERO, substitutionsStorageManager()
    );
}

SalesProject::InfoForReimport SalesProject::getInfoForReimport(dt::Date threshold) const
{
    const auto snailThreshold = [this]() -> dt::Date {
        if (fRealPoints.empty()) {
            return dt::Date::ZERO;
        }
        return reimportThreshold(1, 0, fRealPoints.back().date);
    }();

    return {
        .nRealPoints = nRealPoints(),
        .subst = substitutionsStorageManager(),
        .zeroPoint = point(0),
        .snailThreshold = snailThreshold,
        .pMergeLo = getPMerge(threshold),
        .pMergeLoSnail = getPMerge(snailThreshold),
        .lastPeriodDate = lastPeriodDate(),
        .finder = std::make_unique<ProjectEntries<const SalesProject&>>(*this),
        .avatarFinder = this,
        .categoriesNamesOwner = this
    };
}

void SalesProject::InfoForReimport::makeFinderThreadSafe(std::shared_mutex& aMtx)
{
    finder = std::make_unique<ThreadSafeEntryFinder>(aMtx, std::move(finder));
}

void SalesProject::reduceIbit(size_t aAmount)
{
    if (aAmount == 0)
        return;
    aAmount <<= LostThreshold::SHIFT;
    // Do the job
    for (auto& v : byItem()) {
        for (auto& w : v.second) {
            SalesEntry& entry = *w.second;
            cu_dec(entry.lostThreshold.iBit, aAmount);
        }
    }
}

void SalesProject::buildDayMasks(Array1d<uint32_t>& masks) const
{
    masks.alloc(nRealPoints());
    FOR_S(i, 0, nRealPoints()) {
        const dt::Date& date1 = realPoints(i).date;
        const dt::Date date2 = (i + 1) != nRealPoints() ? periodEnd(i) : fKeyDates.actual;
        masks[i] = lowerBits((date2 - date1) + 1);
    }
}

void SalesProject::trimLostDayBits()
{
    Array1d<uint32_t> masks;
    buildDayMasks(masks);

    // Do the job
    for (auto& v : byItem()) {
        for (auto& w : v.second) {
            SalesEntry& entry = *w.second;
            FOR_S(i, 0, nRealPoints()) {
                entry.realInventory[i].lostDay.intersectAutoMask(masks[i]);
            }
        }
    }
}

void SalesProject::resetHeadingLostDays(SalesEntry& aEntry) const
{
    SplitThreshold st = aEntry.lostThreshold.split(nRealPoints());
    clearLostDayMask(aEntry, 0, st);
}

void SalesProject::resetHeadingLostDays()
{
    for (auto& v : byItem()) {
        for (auto& w : v.second) {
            SalesEntry& entry = *w.second;
            resetHeadingLostDays(entry);
        }
    }
}

void SalesProject::clearLostDayMask(SalesEntry& aEntry, size_t iPoint, const SplitThreshold& st)
{
    FOR_S(i, iPoint, st.iPoint)
        aEntry.realInventory[i].lostDay.clearAutoMask();
    if (st.iBit != 0) {
        uint32_t newMask2 = ~lowerBits(st.iBit);
        aEntry.realInventory[st.iPoint].lostDay.intersectAutoMask(newMask2);
    }
}

// void SalesProject::dumpEntities(const char* aPlace) const
//{
//     std::cout << "dumpEntities IN " << aPlace << std::endl;
//     for (auto& v : byItem()) {
//         for (auto& w : v.second) {
//             std::cout << fmt::format("- Entity so far '{0}/{1}'",
//                                str::w2u(v.first),
//                                str::w2u(w.first)) << std::endl;
//             for (auto& ch : w.second->channels) {
//                 std::cout << fmt::format("-- Channel so far '{}'", str::w2u(*ch.first)) <<
//                 std::endl;
//             }
//         }
//     }
//     std::cout << "dumpEntities OUT" << std::endl;
// }


namespace {

    template <class SalesEntryPtr>
        requires std::is_same_v<SalesEntry, std::decay_t<std::remove_pointer_t<SalesEntryPtr>>>
    class NoEntries : public FinderR<Entity, SalesEntryPtr>
    {
    public:
        SalesEntryPtr find(const Entity&) const override { return nullptr; }

        static NoEntries INST;
    };

    template <class SalesEntryPtr>
        requires std::is_same_v<SalesEntry, std::decay_t<std::remove_pointer_t<SalesEntryPtr>>>
    NoEntries<SalesEntryPtr> NoEntries<SalesEntryPtr>::INST;


}  // namespace

bool SalesProject::isFreewareChannelGood(const ChannelId& aId, const RefStrings& cats)
{
    // No item: entry created, BAD
    auto item = byItem().find(aId.item);
    if (!item)
        return false;
    // No entry: the same
    auto entry = item->find(aId.location);
    if (!entry)
        return false;
    // Entry has no channels - GOOD (we'll drop auto-created one)
    if (entry->channels.empty())
        return true;
    // Otherwise GOOD if found channel
    auto pInfo = fMap->addChannelName(aId.channel, cats);
    auto v = entry->channels.findByName(pInfo);
    return (v != entry->channels.end());
}

namespace {
    bool hasNonZeroOnHand(const SalesEntry& entry) noexcept
    {
        return std::any_of(
            entry.realInventory.begin(), entry.realInventory.end(),
            [](const InventoryPoint& point) { return point.onHand.activeValue(0) != 0; }
        );
    }

    bool hasNonZeroSales(const SalesEntry& entry) noexcept
    {
        return std::any_of(
            entry.channels.begin(), entry.channels.end(),
            [](const auto& channelPair) {
                const auto& [_, channel] = channelPair;
                return std::any_of(
                    channel.realChannel.begin(), channel.realChannel.end(),
                    [](const ChannelPoint& point) { return point.actual.activeValue(0) != 0; }
                );
            }
        );
    }
}

void SalesProject::cleanUnusedEntries(const ConstEntryFinder& aExistingEntries)
{
    for (auto itItem = byItem().begin(); itItem != byItem().end();) {
        auto itNextItem = itItem;
        ++itNextItem;
        auto& item = itItem->second;
        for (auto itEntry = item.begin(); itEntry != item.end();) {
            auto itNextEntry = itEntry;
            ++itNextEntry;

            // store shared_ptr to ensure entry exists untill the end of this scope
            std::shared_ptr<SalesEntry> entry = itEntry->second;

            // 1. Has no expirations
            // 2. Does not exist
            // 3. Has no non-zero and non-empty on-hand
            // 4. Has no non-zero and non-empty sales on channels
            if (!entry->hasExpirations() && !aExistingEntries.find(entry->entity())
                && !hasNonZeroOnHand(*entry) && !hasNonZeroSales(*entry))
            {
                // This is a bad entry!
                // std::cout << fmt::format("Deleted '{}/{}'", str::w2u(entry.code()),
                // str::w2u(entry.locationCode())) << std::endl;
                fMap->deleteEntry(*entry);
            }

            itEntry = itNextEntry;
        }
        itItem = itNextItem;
    }

    //    for (auto& vItem : byItem()) {
    //        for (auto& vEntry : vItem.second) {
    //          SalesEntry& entry = *vEntry.second;
    //          std::cout << fmt::format("Remaining '{}/{}'", str::w2u(entry.code()),
    //          str::w2u(entry.locationCode())) << std::endl;
    //        }
    //    }
}

void SalesProject::resolveByEntryDistribs()
{
    // Link distribution center
    for (auto& vItem : byItem()) {
        auto& item = vItem.second;
        for (auto& vEntry : item) {
            auto& entry = *vEntry.second;
            entry.setByEntryDistrib(entry.byEntryDistrib().locCode);
        }
    }
}

// [[deprecated]] void SalesProject::dumpPromotions(
//         std::wstring_view aItemCode) const
// {
//     std::cout << "DUMP PROMOTIONS of " << str::w2u(aItemCode) << "//" << std::endl;
//     for (auto& v : byItem()) {
//         if (aItemCode.empty() || v.first == aItemCode) {
//             for (auto& w : v.second) {
//                 auto& entry = *w.second;
//                 for (auto& u : entry.channels) {
//                     auto& chan = u.second;
//                     for (auto& promo : chan.promotions.data) {
//                         std::cout << "Entry " << str::w2u(entry.itemCode())
//                                   << "/" << str::w2u(entry.locationCode())
//                                   << "/" << str::w2u(u.first->channel->name)
//                                   << " at " << dt::dateToString(promo.startDate)
//                                   << "..." << dt::dateToString(promo.endDate)
//                                   << std::endl;
//                     }
//                 }
//             }
//         }
//     }
//     std::cout << "-- dump promotions end" << std::endl;
// }


PromotionJob SalesProject::addPromotion(const im::PromotionPoint& aPoint)
{
    PromotionInfo promoInfo{
        .startDate = aPoint.startDate,
        .endDate = aPoint.endDate,
        .discount = aPoint.discount
    };

    if (!aPoint.channelId.channel.empty()) {
        if (!aPoint.channelId.location.empty()) {
            // Have item-location-channel
            SalesChannel* channel = find(aPoint.channelId);
            if (channel) {
                fPromotionsStorage.add(promoInfo, channel->channelId(), aPoint.type);
                return PromotionJob::COMPLETE;
            }
            else {
                return PromotionJob::PARTIAL;
            }
        }
        else {
            // Have item-channel, set all locations and that channel
            DoubleMap::Item* item = findItem(aPoint.channelId.item);
            if (item) {
                for (auto& v : *item) {
                    auto& entry2 = v.second;
                    SalesChannel* channel2 = entry2->find(aPoint.channelId.channel);
                    if (channel2) {
                        fPromotionsStorage.add(promoInfo, channel2->channelId(), aPoint.type);
                    }
                }
            }
            return PromotionJob::PARTIAL;
        }
    }
    else if (!aPoint.channelId.location.empty()) {
        // Have item-location, set all channels
        SalesEntry* entry = find(aPoint.channelId.entity());
        if (entry) {
            for (auto& v : entry->channels) {
                fPromotionsStorage.add(promoInfo, v.second.channelId(), aPoint.type);
            }
        }
        return PromotionJob::PARTIAL;
    }
    else {
        // setting promo to the selected channel or all the channels of item
        DoubleMap::Item* item = findItem(aPoint.channelId.item);
        if (item) {
            for (auto& v : *item) {
                auto& entry2 = v.second;
                for (auto& vv : entry2->channels) {
                    fPromotionsStorage.add(promoInfo, vv.second.channelId(), aPoint.type);
                }
            }
        }
        return PromotionJob::PARTIAL;
    }
}

ReimportTemp::TempPromotions::TempPromotions(const dt::Date& aStartDate, const dt::Date& aThreshold)
    : doesWork(aThreshold.isValid() && aStartDate.isValid() && aThreshold > aStartDate),
      threshold(aThreshold)
{}

PromotionJob ReimportTemp::TempPromotions::addPromotion(const im::PromotionPoint& aPoint)
{
    if (doesWork && aPoint.endDate >= threshold)
        d.push_back(aPoint);
    return PromotionJob::COMPLETE;
}

void ReimportTemp::TempPromotions::dropTo(SalesProject& rProject)
{
    if (doesWork) {
        // doesWork ON — clear imported promotions beyond threshold
        rProject.promotionsStorage().dropTo(threshold);
        // And add new promos
        for (auto& v : d) {
            rProject.addPromotion(v);
        }
    }
    else {
        // doesWork OFF — clear all promotions
        rProject.promotionsStorage().clearByCreationType(CreationType::IMPORT);
    }
}

// [[deprecated, maybe_unused]] void ReimportTemp::TempPromotions::dump(std::wstring_view itemCode)
// {
//     std::cout << "TempPromotions::dump IN" << std::endl;
//     for (auto& v : d) {
//         if (itemCode.empty() || v.channelId.item == itemCode)
//             v.dump_UseInsideDeprecated();
//     }
//     std::cout << "TempPromotions::dump OUT" << std::endl;
// }


// void SalesProject::dumpLostMasks(const std::wstring& aItemCode) const
// {
//     std::string sItem = str::w2u(aItemCode);
//     std::cout << "DUMP LOST MASKS of " << sItem << "//" << std::endl;
//     if (auto item = byItem().find(aItemCode)) {
//         for (auto& v : *item) {
//             std::cout << "Entry <" << sItem << "/" << str::w2u(v.first) << ">" << std::endl;
//             std::cout << "[ ";
//             for (auto q : v.second->realInventory) {
//                 std::cout << std::hex << q.lostDay.autoMask().mask << std::dec << " ";
//             }
//             std::cout << "]" << std::endl;
//         }
//     } else {
//         std::cout << "Item not found" << std::endl;
//     }
//     std::cout << "-- dump lost masks end" << std::endl;
// }

void SalesProject::addChangeLine(ChangeLine line)
{
    fProjectChangelog.add(line);
}

SafeVector<ChangeLine> SalesProject::projectChangelog() const
{
    return fProjectChangelog.getProjectChangelog();
}

void SalesProject::updateAvailableMainTabs(bool val, TabMasks tab)
{
    fAvailableMainTabs.write<Flags<TabMasks>>([val, tab](Flags<TabMasks>* obj) mutable {
        obj->setIf(val, tab);
        obj->removeIf(!val, tab);
    });
}

Flags<TabMasks> SalesProject::availableMainTabs() const
{
    return fAvailableMainTabs.read<Flags<TabMasks>>(
        [](const Flags<TabMasks>* obj) noexcept -> Flags<TabMasks> {
            Flags<TabMasks> newObj = *obj;

            if (licenseInfo().hasFeature(drm::FE_V1_INVENTORY)) {
                newObj |= TabMasks::INVENTORY_REPORT;
            }
            else {
                newObj.remove(TabMasks::INVENTORY_REPORT);
                newObj.remove(TabMasks::INVENTORY_OPTIMIZATION);
            }

            return newObj;
        }
    );
}

void SalesProject::doTraverseChannels(const FilteredChannelPtrCallback& aCb) const
{
    for (auto it = allChannels().begin(); it != allChannels().end(); ++it) {
        auto ch = it.shChannel();
        FilteredChannel fCh(ch, true);
        aCb.act(fCh);
    }
}

void SalesProject::doTraverseByItem(const FilteredChannelPtrCallback& aCb) const
{
    for (const auto& it1 : byItem()) {
        for (const auto& it2 : it1.second) {
            auto spEntry = it2.second;
            for (auto& it3 : spEntry->channels) {
                std::shared_ptr<const SalesChannel> v(spEntry, &it3.second);
                FilteredChannel fCh(v, true);
                aCb.act(fCh);
            }
        }
    }
}

void SalesProject::doTraverseByLocation(const FilteredChannelPtrCallback& aCb) const
{
    for (const auto& it1 : byLocation()) {
        for (const auto& it2 : it1.second) {
            auto spEntry = it2.second;
            for (auto& it3 : spEntry->channels) {
                std::shared_ptr<const SalesChannel> v(spEntry, &it3.second);
                FilteredChannel fCh(v, true);
                aCb.act(fCh);
            }
        }
    }
}

void SalesProject::doTraverseEntries(const FilteredEntryPtrCallbackR& cb) const
{
    for (const auto& [_, entries] : byItem()) {
        for (const auto& [_, entry] : entries) {
            auto filteredEntry = FilteredEntry{entry, true};
            if (cb.act(filteredEntry) == TraverseResult::Stop) {
                return;
            }
        }
    }
}

void SalesProject::markUpdateFailed(ImportFailureType type)
{
    lastUpdateFailure = type;
    lastUpdated = dt::localToday();
}

namespace {

    std::unique_ptr<SubstObject> makeSubstitutionsObject(
        SubstitutionsStorageManager& aSubstitutions, bool combineLocations, std::wstring dataSource
    )
    {
        auto itemSubst = [&]() -> std::unique_ptr<SubstObject> {
            if (combineLocations) {
                return std::make_unique<im::CombinedLocations>(
                    aSubstitutions.itemsSubstStorage(), std::move(dataSource)
                );
            }
            return std::make_unique<im::CompiledSubstitutions>(aSubstitutions.itemsSubstStorage());
        }();

        if (!aSubstitutions.channelsSubstStorage().empty()) {
            return std::make_unique<im::CompiledChannelsSubstitutions>(
                aSubstitutions.channelsSubstStorage(), std::move(itemSubst)
            );
        }

        return itemSubst;
    }

    inline bool exceededChannelsLimit(unsigned nChannels)
    {
        return !licenseInfo().isFull() && nChannels >= licenseInfo().maxFreeChannels();
    }

    inline bool freeLimitHit(double revenue, double qty, unsigned nChannels = 0)
    {
        return !licenseInfo().isFull()
            && (revenue >= licenseInfo().maxFreeRevenue() || qty >= licenseInfo().maxFreeQty()
                || nChannels >= licenseInfo().maxFreeChannels());
    }

}  // anonymous namespace

ImportMetaInfoWithRevenue SalesProject::doImportFromScratch(
    std::unique_ptr<im::Importer>& aImporter, size_t anMaxPoints, const dt::Date& aStartDate,
    const SubstitutionsStorageManager& aSubsts, bool aPrepareForStealing,
    const dt::Date& aExistingLastPeriod, const ConstEntryFinder& aExistingEntities,
    Promotable& aExistingPromotions, const CategoriesNamesOwner& existingCategories,
    const ChannelAvatarFinder& existingAvatars, UpdateType updateType
)
{
    if (anMaxPoints == 0)
        throw ImportNoDataException{};

    /// @brief object that allows to view channel categories of a specific channel
    const ChannelAvatarFinder& activeAvatars
        = aImporter->wantStealCats() ? existingAvatars : NoChannelAvatar::INST;

    bool isDynamic = false;
    if (anMaxPoints == NOT_FOUND) {
        anMaxPoints = 12;
        isDynamic = true;
    }

    fRealPoints.assign(anMaxPoints, RealPoint(dt::Date::ZERO, NO_ARCHIVE));

    ImportMetaInfoWithRevenue rIssuesWithRevenue;

    substitutionsStorageManager() = aSubsts;
    auto importedSubsts = aImporter->substitutions();

    const bool isFullReimport = updateType == UpdateType::FULL;

    // substitutions rules changed => we can apply them only in full reimport
    fRequiresFullReload
        = !isFullReimport && substs::hasChanges(aSubsts.itemsSubstStorage(), importedSubsts.rules);
    setAlert(GeneralAlerts::NEED_RELOAD, fRequiresFullReload);

    /// merge only if it is full reimport!
    /// if nothing was changed, no reason to merge
    /// if it is not full reimport and some changes were made, we ask to make full reimport to omit
    if (isFullReimport) {
        fSubstitutionsStorageManager.itemsSubstStorage().merge(importedSubsts.rules);
    }

    std::unique_ptr<SubstObject> itemSubstObj = makeSubstitutionsObject(
        substitutionsStorageManager(), importedSubsts.combineLocations,
        aImporter->getDataSource().data()
    );

    itemSubstObj->markAsUnused();

    ImportWatchdog watchdog(*this);

    Entity origEntity;
    im::EntryPoint entryData;
    im::ChannelPoint salesData1;
    dt::Date date, licenseLastDate, licenceRenewalDate;

#ifdef LOG_LICENSE
    spdlog::info(
        "SalesProject::doImportFromScratch: drm renewal date - {}",
        dt::dateToString(licenceRenewalDate)
    );
    spdlog::info(
        "SalesProject::doImportFromScratch: max revenue: {}", licenseInfo().maxRevenue.value_or(0)
    );
    spdlog::info(
        "SalesProject::doImportFromScratch: serial date: {}",
        dt::dateToString(licenseInfo().licenseStartDate())
    );
#endif

    bool wasNewItemCreated, wasNewLocationCreated, wasNewEntityCreated;

    bool fIgnoreNext = false,  // limit by revenue or sold items hit, no need to look further
        fWasChannelLimitHit = false;

    const bool hasAnySubstitutions = itemSubstObj->hasReplacements();

    auto rdic = [&]() -> std::unique_ptr<ReplacementDicProto> {
        if (hasAnySubstitutions)
            return std::make_unique<ReplacementDic>(*this, importedSubsts.combineLocations);
        return std::make_unique<DummyReplacementDic>(*this);
    }();

    size_t iPoint = anMaxPoints;
    size_t nChannelsAfterwards = 0;
    [[maybe_unused]] double yearlyRevenueBeforeRenewalFull = 0.0;
    double yearlyRevenueFree = 0.0;
    double yearBeforeLicenseStartQtySold = 0.0;
    bool hasDates = false;
    bool isLastDate = true;

    Lazy<bool> areSubstitutionsCyclic;

    const im::ChannelIdInfo emptyChannelInfo;
    const im::ChannelIdInfo* pChannelInfo = &emptyChannelInfo;

    while (aImporter->nextDate(date)) {
        if (!date.isValid()) {
            throw EPrintf("Error.BadDate", L"You have chosen an invalid date field.");
        }
        // Another stop condition, but first check for validity.
        if (date < aStartDate)
            break;

        hasDates = true;

        // we detect licenseStartDate only once -- in the beggining of the import as the biggest
        // possible date
        licenceRenewalDate = detectLicenseStartDate(date);
#ifdef LOG_LICENSE
        spdlog::info(
            "SalesProject::doImportFromScratch: calculated licenceRenewalDate - {}",
            dt::dateToString(licenceRenewalDate)
        );
#endif

        if (!licenseLastDate.isValid()) {
            licenseLastDate = date;
#ifdef LOG_LICENSE
            spdlog::info(
                "SalesProject::doImportFromScratch: calculated licenseLastDate - {}",
                dt::dateToString(licenseLastDate)
            );
#endif
        }

        if (!areSubstitutionsCyclic.has_value()) {
            auto res = itemSubstObj->initialize(date);
            areSubstitutionsCyclic = (res == SubstObject::Result::CYCLIC);
        }

        // Extend dyn. array
        if (iPoint == 0) {
            if (!isDynamic) {
                break;
            }
            else {  // Otherwise extend dynamic array
                size_t addition = anMaxPoints / 3u + 6;
                anMaxPoints += addition;
                extendStorage(anMaxPoints, InventoryPoint::ALL_LOST);
                rdic->extendBy(addition);
                iPoint = addition;
            }
        }
        --iPoint;
        setPoint(iPoint, date, NO_ARCHIVE);
        const im::ItemInfo* itemInfo;
        const im::LocationInfo* locationInfo;
        const im::EntityInfo* entityInfo;

        // read item/location categories header names
        if (aImporter->wantStealCats()) {
            fItemCatHeaders = existingCategories.itemCatsNames();
            fLocationCatHeaders = existingCategories.locationCatsNames();
        }
        else {
            aImporter->getItemCatNames(fItemCatHeaders);
            aImporter->getLocationCatNames(fLocationCatHeaders);
        }

        BufferStrings itemCatHeaderNamesTrimmed(fItemCatHeaders),
            locationCatHeaderNamesTrimmed(fLocationCatHeaders);
        itemCatHeaderNamesTrimmed.trim();
        locationCatHeaderNamesTrimmed.trim();

        while (aImporter->nextEntity(origEntity, itemInfo, locationInfo, entityInfo, entryData)) {
            // Transform names
            itemSubstObj->doSubstsT(
                origEntity, *itemInfo,
                [&, this](
                    const Entity& aEntity, const im::ItemInfo& aItemInfo,
                    SubstResultInfo substResInfo
                ) {  // multipleRule
                    if (aEntity.item.empty())
                        return;

                    if (fIgnoreNext)
                        return;

                    if (fWasChannelLimitHit && !find(aEntity)) {
                        setFreeLimitHit(
                            yearlyRevenueFree, yearBeforeLicenseStartQtySold, nChannelsAfterwards
                        );
                        return;
                    }


                    BufferStrings itemCats(aItemInfo.cats), locationCats(locationInfo->cats);
                    itemCats.trim(itemCatHeaderNamesTrimmed.size());  // fit to names
                    locationCats.trim(locationCatHeaderNamesTrimmed.size());  // fit to names

                    std::weak_ptr<SalesEntry> wptrEntry = atEx(
                        aEntity, itemCats, locationCats, wasNewItemCreated, wasNewLocationCreated,
                        wasNewEntityCreated
                    );
                    ReplacementDicResult rdicResult = rdic->add(
                        origEntity, substResInfo.isActuallyInvolved, wptrEntry, wasNewEntityCreated
                    );
                    SalesEntry& entry = *wptrEntry.lock();


                    if (wasNewEntityCreated) {
                        if (exceededChannelsLimit(++nChannelsAfterwards))
                            fWasChannelLimitHit = true;

                        FOR_S(i, 0, nRealPoints()) {
                            /// trim mask for last period later when know lattest transaction date
                            entry.realInventory[i].lostDay.raiseAutoMask();
                        }
                        entry.temp1 = 0;
                        entry.entryInfo() = *entityInfo;
                        if (auto datasource = aImporter->getDataSource(); !datasource.empty()) {
                            entry.entryInfo().dataSource = datasource;
                        }
                        if (wasNewItemCreated) {
                            entry.item().info = aItemInfo;
                        }
                        if (wasNewLocationCreated) {
                            entry.location().info.description = locationInfo->description;
                            entry.location().info.transferRegion = locationInfo->transferRegion;
                        }

                        // Save its DC
                        if (!entityInfo->nonAggr.distribCenter.empty()
                            && entityInfo->nonAggr.distribCenter != aEntity.location)
                        {
                            entry.setExternalByEntryDistrib(entityInfo->nonAggr.distribCenter);
                        }
                    }
                    else {
                        if (hasAnySubstitutions && substResInfo.canBeFinalTarget)
                        {  // Orig entity that can be the target
                            // If we found an item, which is prototype of kitted item, copy its
                            // settings
                            if (!hasFlag(entry.item().itemFlags, FG_REAL))
                            {  // No real flag in actual item, so original item wasnt seen yet
                                fMap->changeCats(entry.item(), itemCats);
                                entry.item().info = aItemInfo;
                            }

                            // original wasn't seen => propper info wasn't set yet
                            const bool wasOriginalSeen
                                = rdic->wasOriginalPrototypeOfEntrySeen(origEntity, entry);

                            // If we found an entry, which is prototype of kitted entry, copy its
                            // settings
                            if (!wasOriginalSeen) {  // this original entry wasnt seen yet
                                entry.entryInfo() = *entityInfo;
                            }
                        }
                    }

                    if (auto& groupName
                        = ((!entityInfo->nonAggr.group.name.empty())
                               ? entityInfo->nonAggr.group.name
                               : entityInfo->nonAggr.supplierCode);
                        !groupName.empty())
                    {
                        Group gr(entityInfo->nonAggr.group);
                        gr.fName = groupName;
                        if (gr.isValid()) {
                            inventoryCollector().insertOrAssignImportedGroup(
                                utils::generateId<InvCollectionCacheId>(), gr
                            );
                        }
                    }

                    if (!entityInfo->nonAggr.container.name.empty()) {
                        inventoryCollector().insertOrAssignImportedContainer(
                            utils::generateId<InvCollectionCacheId>(), entityInfo->nonAggr.container
                        );
                    }

                    // New ORIGINAL entity?
                    if (rdicResult.wasAdded) {
                        // Arrivals
                        for (auto ar : entityInfo->other.arrivals) {
                            ar.qty = ar.qty.activeValue(0) * substResInfo.multiplier;
                            utils::add(
                                inTransitionStorageManager().arrivalStorage(), entry.entity(),
                                {std::move(ar)}
                            );
                            entry.updateArrivalPlaceDate(ar.placeDate.activeValue());
                        }
                        // TableBackorder
                        for (const Backorder& bo : entityInfo->other.backorders) {
                            if constexpr (!dbg::ITEM.empty()) {
                                if (aEntity.item == dbg::ITEM) {
                                    std::wcout << fmt::format(
                                        L"Found backorder: loc <{}>, chan <{}>, qty {}, doc <{}>",
                                        aEntity.location, bo.channel, bo.qty.activeValue(0),
                                        bo.docNumber.activeValue()
                                    ) << std::endl;
                                }
                            }
                            auto newBackorder = bo;
                            newBackorder.qty = bo.qty.activeValue(0) * substResInfo.multiplier;
                            utils::add(
                                inTransitionStorageManager().backorderStorage(), entry.entity(),
                                std::move(newBackorder)
                            );
                        }
                        // Other things
                    }

                    /// @todo [imma] FG_VIRTUAL actually unneeded
                    entry.item().itemFlags
                        |= substResInfo.isActuallyInvolved ? FG_VIRTUAL : FG_REAL;

                    InventoryPoint& myInvPoint = entry.realInventory[iPoint];
                    bool wasImportantUsed = myInvPoint.add(
                        entryData, entityInfo->other.lastOnHand, iPoint + 1 == anMaxPoints,
                        substResInfo.multiplier
                    );

                    size_t& iOrigPoint = rdicResult.threshold->iOnHandKnown;

                    // No on hand → no point checking
                    if (entryData.onHand.isSet()) {
                        // Use lost days for adding points
                        if (iOrigPoint > iPoint) {
                            size_t pLast = std::min(iOrigPoint, anMaxPoints);
                            im::EntryPoint ep;
                            ep.onHand = entryData.onHand;  // the rest are 0’s
                            //  POINT   !   !   !   ORIG
                            //  All !-marks: copy OH and avgOH
                            FOR_S(p1, iPoint + 1, pLast) {
                                InventoryPoint& point = entry.realInventory[p1];
                                point.add(
                                    ep, entityInfo->other.lastOnHand, p1 + 1 == anMaxPoints,
                                    substResInfo.multiplier
                                );
                                point.addAvg(
                                    entryData.onHand.valueOrNan<float>(), substResInfo.multiplier
                                );
                            }
                            //  ORIG: build up avg
                            if (iOrigPoint < anMaxPoints) {
                                float val = rdicResult.threshold->lastAvgOnHand.fullValue(
                                    entryData.onHand.valueOrNan<float>()
                                );
                                entry.realInventory[iOrigPoint].addAvg(
                                    val, substResInfo.multiplier
                                );
                            }
                        }
                        rdicResult.threshold->lastAvgOnHand = entryData.avgOnHand;
                        iOrigPoint = iPoint;
                    }
                    else if (wasImportantUsed) {
                        // If we set the most important OH, reflect this!
                        iOrigPoint = iPoint;
                    }

                    // Lost day bits
                    if (entryData.firstKnownLostDay < im::EntryPoint::UNKNOWN_DAY) {
                        size_t newAmalgamated
                            = (iPoint << LostThreshold::SHIFT) | entryData.firstKnownLostDay;
                        size_t& iBit = rdicResult.threshold->iBit;
                        if (newAmalgamated < iBit) {
                            SplitThreshold origSt = rdicResult.threshold->split(nRealPoints());
                            uint32_t newMask1 = lowerBits(entryData.firstKnownLostDay);
                            uint32_t newMask2 = entryData.lostDayMask | newMask1;
                            myInvPoint.lostDay.intersectAutoMask(newMask2);
                            // We have current mask, but the only way to check the rest is to test
                            // onHand.
                            if (entryData.onHand.activeValue(1) != 0) {
                                clearLostDayMask(entry, iPoint + 1, origSt);
                            }

                            iBit = newAmalgamated;
                        }
                    }
                }
            );
        }  // while (nextEntity)

        ChannelId origChannelId;
        im::SnailChannelInfo snailChannelInfo1;

        while (aImporter->nextChannel(origChannelId, pChannelInfo, snailChannelInfo1, salesData1)) {
            //            Entity itsOrigEntity = origChannelId.entity();
            itemSubstObj->doSubstsT(
                origChannelId, *itemInfo,
                [&, this](
                    const ChannelId& aChannelId, const im::ItemInfo& aItemInfo,
                    SubstResultInfo substResInfo
                ) {
                    if (aChannelId.item.empty())
                        return;

                    im::ChannelPoint channelData2 = salesData1;
                    im::SnailChannelInfo snailChannelInfo2 = snailChannelInfo1;

                    BufferStrings itemCats(aItemInfo.cats), locationCats(locationInfo->cats),
                        channelCats(pChannelInfo->cats);

                    itemCats.trim();
                    locationCats.trim();
                    channelCats.trim();
                    const RefStrings* activeChannelCats = &channelCats;

                    LazyChannelCats lazyCats;
                    if (channelCats.size() == 0) {
                        if (auto q = activeAvatars.findChannelAvatar(aChannelId)) {
                            lazyCats = q;
                            activeChannelCats = &lazyCats;
                        }
                    }

                    if (fIgnoreNext)
                        return;

                    if (fWasChannelLimitHit && !isFreewareChannelGood(aChannelId, channelCats)) {
                        setFreeLimitHit(
                            yearlyRevenueFree, yearBeforeLicenseStartQtySold, nChannelsAfterwards
                        );
                        return;
                    }


                    bool wasNewChannelCreated;
                    SalesChannel& channel = channelAt(
                        aChannelId, itemCats, locationCats, *activeChannelCats, wasNewItemCreated,
                        wasNewLocationCreated, wasNewEntityCreated, wasNewChannelCreated
                    );
                    if (wasNewChannelCreated) {
                        if (channel.entry().channels.size() > 1) {
                            if (exceededChannelsLimit(++nChannelsAfterwards))
                                fWasChannelLimitHit = true;
                        }
                    }

                    if (substResInfo.isMultipleRule) {
                        snailChannelInfo2.dayProfit.reset();  // do we need to do this actually?
                        channelData2.profit = std::numeric_limits<float>::quiet_NaN();
                        channelData2.avgPrice = std::numeric_limits<float>::quiet_NaN();
                    }
                    else if (!isFinite(channelData2.avgPrice)) {
                        channelData2.avgPrice = channel.entry().entryInfo().sellPrice.valueOrNan();
                    }

                    if (isLastDate) {
                        channel.snailInfo.setAll(snailChannelInfo2, (date == aExistingLastPeriod));
                    }

                    ChannelPoint& myChannelPoint = channel.realChannel[iPoint];
                    const auto [sales, revenue]
                        = myChannelPoint.add(channelData2, substResInfo.multiplier);
                    channel.addImpotedOutlier(iPoint, channelData2.importedOutlier);

                    if (dt::daysBetweenTwoDates(date, licenseLastDate)
                        <= dt::daysInYear(licenseLastDate.year))
                    {
                        if (isFinite(sales)) {
                            yearBeforeLicenseStartQtySold += sales;
                        }
                        if (isFinite(revenue)) {
                            yearlyRevenueFree += revenue;
                        }
                    }

                    if (date <= licenceRenewalDate && isFinite(revenue)
                        && dt::daysBetweenTwoDates(licenceRenewalDate, date)
                               <= dt::daysInYear(licenceRenewalDate.year))
                    {
                        rIssuesWithRevenue.lastYearRevenue += revenue;
#ifdef LOG_LICENSE
                        spdlog::info(
                            "SalesProject::doImportFromScratch: item {}, location {}, channel {}, "
                            "date {}, adding revenue {}, now total last year revenue is {}",
                            str::w2u(channel.itemCode()), str::w2u(channel.locationCode()),
                            str::w2u(channel.channelName()), dt::dateToString(date), revenue,
                            rIssuesWithRevenue.lastYearRevenue
                        );
#endif
                    }

                    if (freeLimitHit(yearlyRevenueFree, yearBeforeLicenseStartQtySold)) {
                        setFreeLimitHit(
                            yearlyRevenueFree, yearBeforeLicenseStartQtySold, nChannelsAfterwards
                        );
                        fIgnoreNext = true;
                    }

                    yearlyRevenueBeforeRenewalFull = rIssuesWithRevenue.lastYearRevenue;
#ifndef STREAMLINE_SERVER
                    if (licenseUtils::doubleCheckFullLimitHit(yearlyRevenueBeforeRenewalFull)) {
    #ifdef LOG_LICENSE
                        spdlog::info("SalesProject::doImportFromScratch: full limit hit!");
    #endif
                        setFullLimitHit(yearlyRevenueBeforeRenewalFull, licenceRenewalDate);
                        fIgnoreNext = true;
                    }
#endif
                }
            );
        }  // while (nextChannel)

        isLastDate = false;
    }  // while (nextDate)

    if (!hasDates)
        throw ImportNoDataException{};

    if (!licenceRenewalDate.isValid())
        throw UNEXPECTED_EXCEPTION("Invalid license start date.");

    // read categories header names
    // channel categories headers are read in aImporter->nextChannel,
    // so we should assign them here, after channels traversal
    if (aImporter->wantStealCats()) {
        fChannelCatHeaders = existingCategories.channelCatsNames();
    }
    else {
        aImporter->getChannelCatNames(fChannelCatHeaders);
    }

    {
        Array1d<std::wstring> infoFields;
        aImporter->getArrivalInfoFields(infoFields);
        inTransitionStorageManager().arrivalStorage().setInfoFieldNames(std::move(infoFields));
        infoFields.clear();
        aImporter->getBackorderInfoFields(infoFields);
        inTransitionStorageManager().backorderStorage().setInfoFieldNames(std::move(infoFields));
    }

    aImporter->getInfoFields(fAuxFields);

    im::ItemInfo itemInfo;
    // Expiration dates
    if (nRealPoints() != 0) {
        aImporter->doExpirationT([&, this](const im::ExpirationPoint& aPoint) {
            itemSubstObj->doSubstsT(
                aPoint.entity, itemInfo,
                [&, this](const Entity& aTransfEntity, const im::ItemInfo&, SubstResultInfo) {
                    SalesEntry* entry = find(aTransfEntity);
                    if (entry) {
                        entry->expiration.addExpiration(
                            aPoint.expirationDate, aPoint.batchOnHand, aPoint.batch
                        );
                    }
                }
            );
        });
    }

    if (aImporter->wantCleanUnusedEntries()) {
        cleanUnusedEntries(aExistingEntities);
        if (auto threadSafeFinder = dynamic_cast<const ThreadSafeEntryFinder*>(&aExistingEntities))
        {
            threadSafeFinder->endCriticalSection();
        }
    }

    resolveByEntryDistribs();

    // Marking Locations as Dedicated DC
    findDedicatedDistribCenters();

    if (aPrepareForStealing) {
        if (iPoint < anMaxPoints) {
            aImporter->onHandBefore([&, this](const im::OnHandPoint& aPoint) {
                itemSubstObj->doSubstsT(
                    aPoint.entity, itemInfo,
                    [&, this](
                        const Entity& aTransfEntity, const im::ItemInfo&,
                        SubstResultInfo substResInfo
                    ) {
                        // aPoint.entity = original, aTransfEntity = transformed
                        SalesEntry* entry = find(aTransfEntity);
                        if (!entry) {
                            return;
                        }
                        const LostThreshold* lt
                            = rdic->find(aPoint.entity, substResInfo.isActuallyInvolved, *entry);
                        if (!lt) {
                            return;
                        }
                        size_t pLast = std::min(lt->iOnHandKnown, anMaxPoints - 1);
                        FOR_SE(p1, 0, pLast) {
                            InventoryPoint& point = entry->realInventory[p1];
                            float val;
                            if (p1 == lt->iOnHandKnown) {
                                val = lt->lastAvgOnHand.fullValue(aPoint.value);
                            }
                            else {
                                val = aPoint.value;
                            }
                            point.addAvg(val, substResInfo.multiplier);
                        }
                    }
                );
            });
        }
    }
    else {
        autoCreateChannels();
    }

    baseCurrency = aImporter->baseCurrency();

    if (!baseCurrency.empty())
        sets.customCurrency = baseCurrency;

    fKeyDates = aImporter->keyDates();
    itsShelfLifeUnit = aImporter->shelfLifeUnit();
    importedOC = aImporter->orderCycleUnit();

    if (importedOC.has_value()) {
        sets.resetOrderCycleUnit(*importedOC);
    }

    rdic->amalgamateIndexes();

    reduceIbit(iPoint);

    size_t nPointsRemaining = anMaxPoints - iPoint;
    shrinkTo(nPointsRemaining);

    // cache pCurrKnown after shrink of real points
    cachePCurrKnown();

    if (nRealPoints() != 0) {
        // On hand from

        // All known OnHand producers disallow lost days reconstruction
        auto startIt = fRealPoints.begin();
        auto endIt = fRealPoints.end();
        aImporter->onHandFrom(
            realPoints(0).date,
            [this, startIt, endIt](const im::OnHandPoint& aPoint) {
                SalesEntry* entry = find(aPoint.entity);
                if (entry) {
                    auto it = std::upper_bound(startIt, endIt, aPoint.date, dateLessPoint);
                    if (it != startIt) {
                        auto iDate = it - startIt - 1;
                        entry->realInventory[iDate].onHand = aPoint.value;
                    }
                }
            }
        );

        // Promotions
        aImporter->doPromotionT([this, &aExistingPromotions](const im::PromotionPoint& aPoint) {
            if (addPromotion(aPoint) == PromotionJob::PARTIAL) {
                aExistingPromotions.addPromotion(aPoint);
            }
        });

        // Bugfix of empty archives after import
        setOnlyPointPart(nRealPoints() - 1, 1.0);
    }  // nRealPoints != 0

    fixupExpirationOnHand();

    //    for ( auto it = allChannels().begin(); it != allChannels().end(); ++it ) {
    //        auto sc = it.shChannel()->channelId();
    //        std::wstring str = fmt::format(L"{0}{1}{2} ", sc.channel, sc.item, sc.location);
    //        std::wcout << str << " ";
    //        for (auto& v : it->promotions.data) {
    //                str = fmt::format(L"discount: {}", v.discount);
    //                std::wcout << str << " ";
    //        }
    //        std::wcout << std::endl;
    //    }

    auto bomsWithSubsts = BomsWithSubstitutions{*itemSubstObj, importedSubsts.combineLocations};


    aImporter->bom([&](const std::wstring& whole, const std::wstring& location,
                       const std::wstring& part, im::BomImportInfo bomInfo) {
        bomsWithSubsts.insertBomReceipt(fBom, whole, location, part, bomInfo);
    });

    aImporter->doInvParametersT(
        [this](const Entity& entity, int point, const im::InventoryParameters& params) {
            if (auto entry = find(entity)) {
                if (params.maxBundle.isSet()) {
                    entry->entryInfo().maxBundle.dynamic.put(point, params.maxBundle);
                }
            }
        }
    );

    std::vector<Supplier> supplierObjs;

    aImporter->doSupplierT([this, &substs = *itemSubstObj, &supplierObjs](Supplier&& obj) {
        substs.doSubstsT(
            Entity{obj.item, str::wempty}, im::ItemInfo{},
            [&obj](const Entity& transEntity, const im::ItemInfo&, SubstResultInfo) {
                obj.item = transEntity.item;
            }
        );

        if (hasItem(obj.item)) {
            supplierObjs.push_back(std::move(obj));
        }
    });

    fSuppliersStorage.add(std::move(supplierObjs));

    if (!aPrepareForStealing) {
        removeWildcards();
    }

    /// Steal internal connectors issues
    if (auto issue = aImporter->detachIssues(); !std::holds_alternative<std::monostate>(issue)) {
        rIssuesWithRevenue.add(std::move(issue));
    }

    if (areSubstitutionsCyclic == true) {
        rIssuesWithRevenue.add(CyclicSubstitutionsIssue{});
    }

    predictDates(aImporter->dateProgression());

    aImporter.reset();

    removeInvalidContainerOverrides();
    removeInvalidGroupOverrides();

    // during import we store revenue in channelPoint.avgPrice
    // here we convert it to average price: divide it by actual sales
    convertCostsToPrices();

    checkCurrencies();
    fillOnHandHoles();
    areChannelsTrivialCache.reset();
    trimLostDayBits();

    modify();
    fWantsFullReload = false;

    lastUpdated = dt::localToday();
    lastUpdateFailure = ImportFailureType::NONE;
    fContainsSnailInfo = true;

    intrinsicCache.rebuildArchivePointsIndices(fRealPoints);
    precisionCache.value = PRECISION_UNCACHED;

    watchdog.disable();

    return rIssuesWithRevenue;
}

namespace {
    template <typename Type>
    void shiftArray(Array1d<Type>& rArray, size_t aShift)
    {
        if (aShift == 0 || aShift >= rArray.size())
            return;
        Array1d<Type> temp(rArray.size());
        std::copy(rArray.begin(), rArray.end() - aShift, temp.begin() + aShift);
        rArray = std::move(temp);
    }
}

ImportMetaInfoWithRevenue SalesProject::doImportFromScratch(
    im::MultipleImporters& aImporters, size_t anMaxPoints, const dt::Date& aStartDate,
    const SubstitutionsStorageManager& aSubsts, bool aPrepareForStealing,
    const dt::Date& aExistingLastPeriod, const ConstEntryFinder& aExistingEntries,
    Promotable& aExistingPromotions, const CategoriesNamesOwner& existingCategories,
    const ChannelAvatarFinder& existingAvatars, UpdateType updateType
)
{
    ImportMetaInfoWithRevenue rIssuesWithRevenue;
    size_t idx = 0;
    std::vector<std::unique_ptr<SalesProject>> subProjects;
    auto dateProgression = aImporters.front()->dateProgression();  // no matter which importer

    // find first non empty importer
    for (; idx < aImporters.size(); ++idx) {
        try {
            rIssuesWithRevenue.stealDataFrom(doImportFromScratch(
                aImporters[idx], anMaxPoints, aStartDate, aSubsts, aPrepareForStealing,
                aExistingLastPeriod, aExistingEntries, aExistingPromotions, existingCategories,
                existingAvatars, updateType
            ));

            ++idx;
            fKeyDates.oldestActual = fKeyDates.actual;
            break;
        } catch (const ImportNoDataException&) {
            if (idx == aImporters.size() - 1) {
                throw;  // if it's last importer and there's still no data - rethrow
            }
            else {
                continue;
            }
        }
    }

    if (idx < aImporters.size()) {
        size_t auxSize = fAuxFields.size();

        std::vector<SalesProject*> allProjects;
        allProjects.push_back(this);

        FOR_S(i, idx, aImporters.size()) {
            auto sp = std::make_unique<SalesProject>();
            try {
                rIssuesWithRevenue.stealDataFrom(sp->doImportFromScratch(
                    aImporters[i], anMaxPoints, aStartDate, aSubsts, aPrepareForStealing,
                    aExistingLastPeriod, aExistingEntries, aExistingPromotions, existingCategories,
                    existingAvatars, updateType
                ));
            } catch (const ImportNoDataException&) {
                continue;
            }

            fKeyDates.oldestActual = std::min(sp->fKeyDates.actual, fKeyDates.oldestActual);
            fKeyDates.actual = std::max(sp->fKeyDates.actual, fKeyDates.actual);

            auxSize += sp->fAuxFields.size();
            subProjects.push_back(std::move(sp));
            allProjects.push_back(subProjects.back().get());
        }
        if (subProjects.size() == 0) {
            return rIssuesWithRevenue;
        }

        // revenue limit
        if (auto maxRevenue = licenseInfo().maxRevenue();
            maxRevenue && rIssuesWithRevenue.lastYearRevenue > *maxRevenue)
            throw WideException(L"Revenue limit was exceeded"
            );  /// @todo common format for revenue issue

        Array1d<std::wstring> allAuxFieldsNames(auxSize);
        std::vector<RealPoint> allPoints;
        auto realPointMin = &fRealPoints;
        auto realPointMax = &fRealPoints;
        for (auto& rPs : subProjects) {
            if (rPs->fRealPoints.front().date < realPointMin->front().date) {
                realPointMin = &rPs->fRealPoints;
            }
            if (rPs->fRealPoints.back().date > realPointMin->back().date) {
                realPointMax = &rPs->fRealPoints;
            }
        }

        fRealPoints = *realPointMin;
        predictDates(dateProgression);


        if (realPointMax != realPointMin) {
            size_t counter = nRealPoints();
            while (fRealPoints.back().date != realPointMax->back().date) {
                RealPoint p{point(counter), -1};
                fRealPoints.push_back(p);
                counter += 2;
            }
            fRealPoints.back() = realPointMax->back();
        }
        allPoints = fRealPoints;

        size_t currAuxNameIdx = 0, beforeAuxAdd = 0;
        for (auto& project : allProjects) {
            for (const auto& auxFieldName : project->fAuxFields) {
                allAuxFieldsNames[currAuxNameIdx++] = auxFieldName;
            }

            size_t leftShift = 0;
            if (project->fRealPoints.size() != allPoints.size()) {
                while (project->fRealPoints[0].date != allPoints[leftShift].date) {
                    leftShift++;
                }
            }
            // channel point
            for (auto it = project->allChannels().begin(); it != project->allChannels().end(); ++it)
            {
                SalesChannel& channel = *it.shChannel();
                Array1d<ChannelPoint>& channelPoints = channel.realChannel;
                channelPoints.resize(allPoints.size());
                shiftArray(channelPoints, leftShift);
            }

            // inventory point
            for (auto& [itemCode, item] : project->byItem()) {
                for (auto& [locCode, entryPtr] : item) {
                    SalesEntry& entry = *entryPtr;

                    Array1d<InventoryPoint>& inventoryPoints = entry.realInventory;
                    size_t oldSize = inventoryPoints.size();
                    inventoryPoints.resize(allPoints.size());
                    shiftArray(inventoryPoints, leftShift);

                    // set onhand for new real point
                    for (size_t i = oldSize + leftShift; i < inventoryPoints.size(); ++i) {
                        inventoryPoints[i] = inventoryPoints[oldSize + leftShift - 1];
                    }

                    // aux fields
                    auto idx = beforeAuxAdd;
                    Array1d<OverrideableWstring> localAuxF(allAuxFieldsNames.size());
                    for (auto& field : entry.entryInfo().auxFields) {
                        localAuxF[idx++] = field;
                        auxSize++;
                    }
                    entry.entryInfo().auxFields = std::move(localAuxF);
                }
            }
            beforeAuxAdd += project->nAuxFields();

            project->fRealPoints = allPoints;
            if (project != this) {
                fMap->addEntries(*project->fMap);

                fSubstitutionsStorageManager.merge(project->substitutionsStorageManager());
                fBom.merge(project->fBom);
                fInvBom.merge(project->fInvBom);
                fMap->stealChannelNames(project->fMap);
                inventoryCollector().mergeData(project->fInventoryCollector);
            }
        }
        fAuxFields = allAuxFieldsNames;
    }

    resolveByEntryDistribs();
    findDedicatedDistribCenters();
    predictDates(dateProgression);

    return rIssuesWithRevenue;
}

void SalesProject::recollectAlertsData(alerts::RefreshType type)
{
    if (type == alerts::RefreshType::MODEL_QUALITY) {
        /// @todo Generalise for other thresholds when there are any.
        alerts::AllData::AlertsList& cat = alertsData.alertsAt(alerts::Category::MODEL_QUALITY);
        cat.clear();
        for (auto& channel : allChannels()) {
            channel.recalcAlerts(*this, pCurrKnown(), alertsData.thresholds);
            alertsData.collectAlertsFrom(&channel);
        }
    }
    else {
        alertsData.clear();
        for (const auto& [_, item] : byItem()) {
            alertsData.collectAlertsFrom(&item.info);
        }
        for (auto& entry : allEntries()) {
            alertsData.collectAlertsFrom(&entry);
            for (auto& [_, channel] : entry.channels) {
                channel.recalcAlerts(*this, pCurrKnown(), alertsData.thresholds);
                alertsData.collectAlertsFrom(&channel);
            }
        }
        alertsData.collectAlertsFrom(this);
    }
}

bool SalesProject::hasNoItem(const std::wstring& aItemName) const
{
    return findItem(aItemName) == nullptr;
}

SalesProject::ListOfItemsToRename SalesProject::getItemsToRename() const
{
    ListOfItemsToRename itemsToRename;

    for (const auto& rule : fSubstitutionsStorageManager.itemsSubstStorage().getAll()) {
        if (rule->substRule.target.isUsed != TriBool::TRU
            && hasNoItem(rule->substRule.target.target.activeValue()))
        {
            itemsToRename.emplace_back(
                rule->substRule.source.activeValue(), rule->substRule.target.target.activeValue()
            );
        }
    }
    return itemsToRename;
}

const dt::Date& SalesProject::lastPeriodDate() const
{
    if (nRealPoints() != 0)
        return realPoints(nRealPoints() - 1).date;
    return dt::Date::ZERO;
}

dt::Date SalesProject::detectLicenseStartDate(const dt::Date& lastDate) const
{
    if (licenseInfo().lastPaymentDate().isValid())
        return licenseInfo().lastPaymentDate();
    // lastDate is date as of last transaction, serial date is the date of very first activation
    dt::Date serialDate = licenseInfo().licenseStartDate();
    dt::Date licenseStartDate = serialDate;
    if (lastDate < serialDate || !serialDate.isValid())
        licenseStartDate = lastDate;
    else if (lastDate > serialDate) {
        // we need 365 days to detect the number of full years past, no need in 366
        int daysInYear = std::min(dt::daysInYear(lastDate.year), dt::daysInYear(serialDate.year));
        int fullYearsPast = (lastDate.toInt() - serialDate.toInt()) / daysInYear;
        licenseStartDate.year += fullYearsPast;
    }

    return licenseStartDate;
}

ImportMetaInfo SalesProject::importFromScratch(
    std::unique_ptr<im::Importer>& aImporter, size_t anMaxPoints, const dt::Date& aStartDate,
    const SubstitutionsStorageManager& aSubsts
)
{
    return importFromScratchT(aImporter, anMaxPoints, aStartDate, aSubsts);
}

ImportMetaInfo SalesProject::importFromScratch(
    im::MultipleImporters& aImporters, size_t anMaxPoints, const dt::Date& aStartDate,
    const SubstitutionsStorageManager& aSubsts
)
{
    return importFromScratchT(aImporters, anMaxPoints, aStartDate, aSubsts);
}

namespace {

    dt::Date getStartDate(im::MultipleImporters& aImporter, const dt::Date& aThreshold)
    {
        auto minIt = std::min_element(
            aImporter.begin(), aImporter.end(),
            [](std::unique_ptr<im::Importer>& first, std::unique_ptr<im::Importer>& second) {
                return first->actualStartDate() < second->actualStartDate();
            }
        );
        dt::Date r = (*minIt)->actualStartDate();
        if (r.isValid()) {
            r.modifyToLatter(aThreshold);
        }
        else {
            r = aThreshold;
        }
        return r;
    }

    //    im::AssortmentMode getAssortmentMode(const im::MultipleImporters& aImporters){
    //        auto minElement = aImporters.front()->assortmentMode();
    //        FOR_S(i, 1, aImporters.size()){
    //            minElement = std::min(minElement, aImporters[i]->assortmentMode());
    //        }
    //        return minElement;
    //    }
}  // namespace

std::unique_ptr<ReimportTemp> reimportToTemp(
    const SalesProject::InfoForReimport& projectInfo, im::MultipleImporters& aImporters,
    size_t anMaxPoints, const dt::Date& aThreshold, UpdateType updateType,
    im::log::LogsBundleId logsId
)
{
    auto& logger = im::log::getLogger(logsId, im::log::MAIN);
    auto info = std::make_unique<ReimportTemp>(logger);
    info->oldThreshold = aThreshold;

    logger.info("reimport IN");
    logger.info(str::w2u(
        Wprintf(EnglishPlural::instance, L"Old file: {1|q=point:s}")(projectInfo.nRealPoints)
    ));

    info->assortmentMode = /*getAssortmentMode(aImporter)*/ im::AssortmentMode::
        NONE;  /// @todo [multiple connector] do assormentMode algorithm
               /// entry will copy from old project with NONE
    info->importStartDate = getStartDate(aImporters, aThreshold);
    info->mergeThreshold = aThreshold;
    info->progression = aImporters.back()->dateProgression(
    );  // dateProgression should be the same for all importers
    info->pMergeLo = projectInfo.pMergeLo;

    if (info->importStartDate == info->mergeThreshold && info->pMergeLo == projectInfo.nRealPoints)
    {  // [+] snailImport enabled
        info->mergeThreshold = info->importStartDate = projectInfo.snailThreshold;
        info->pMergeLo = projectInfo.pMergeLoSnail;
    }


    logger.info("Threshold is {}", dt::dateToString(info->mergeThreshold));

    ConstEntryFinder& finder
        = (info->pMergeLo == 0) ? static_cast<ConstEntryFinder&>(NoEntries<const SalesEntry*>::INST)
                                : *projectInfo.finder;
    info->tempPromo = std::make_unique<ReimportTemp::TempPromotions>(
        projectInfo.zeroPoint, info->importStartDate
    );

    logger.info("doImportFromScratch CALL");
    info->importMetaInfo = info->imported.doImportFromScratch(
        aImporters, anMaxPoints, info->importStartDate, projectInfo.subst, true,
        projectInfo.lastPeriodDate, finder, *info->tempPromo, *projectInfo.categoriesNamesOwner,
        *projectInfo.avatarFinder, updateType
    );

    logger.info("doImportFromScratch OK");
    logger.info(str::w2u(
        Wprintf(EnglishPlural::instance, L"New file: {1|q=point:s}")(info->imported.nRealPoints())
    ));

    return info;
}

void SalesProject::merge(std::unique_ptr<ReimportTemp> aInfo)
{
    spdlog::logger& logger = aInfo->logger;
    // now transfer everything to tmp!
    const size_t pMergeHi
        = (!aInfo->mergeThreshold.isValid()) ? 0
        : (aInfo->imported.nRealPoints() != 0)
            ? std::max(aInfo->pMergeLo, getPMerge(aInfo->imported.realPoints(0).date))
            : nRealPoints();

    aInfo->tempPromo->dropTo(*this);
    logger.info("Drop promotions OK");

    logger.info(
        "Stealing: merge={}...{}, assortment={}", aInfo->pMergeLo, pMergeHi,
        (enumName(aInfo->assortmentMode))
    );

    logger.info("Steal CALL");

    bool hasWildcards = imManager.hasFeature(im::ModuleFeatures::WILDCARDS);

    if (isSimulation()) {
        aInfo->imported.fInventoryCollector = fInventoryCollector;
        aInfo->imported.suppliersStorage() = suppliersStorage();
        aInfo->imported.fBom = fBom;
        aInfo->imported.fInvBom = fInvBom;
    }

    auto promoStealDataPolicy = aInfo->tempPromo->doesWork ? promo::StealDataPolicy::All
                                                           : promo::StealDataPolicy::ByThreshhold;

    aInfo->imported.stealDataFrom(
        *this, aInfo->oldThreshold, aInfo->pMergeLo, pMergeHi, aInfo->assortmentMode, logger,
        hasWildcards, aInfo->progression, promoStealDataPolicy
    );
    logger.info("Steal OK");

    *this = std::move(aInfo->imported);
    logger.info("Move OK");

    fixupOwnership();
    logger.info("fixupOwnership OK");

    autoCreateChannels();
    logger.info("autoCreateChannels OK");

    predictDates(aInfo->progression);
    logger.info("predictDates OK");

    checkCurrencies();
    logger.info("checkCurrencies OK");

    fillOnHandHoles();
    logger.info("fillOnHandHoles OK");

    resolveByEntryDistribs();
    rebuildDistribBomCache(true);
    logger.info("findDedicatedDistribCenters OK");

    checkAndFixUsersTreeSettings();
    recache();
    recacheAvatarsChannels();
    intrinsicCache.rebuildArchivePointsIndices(fRealPoints);
    precisionCache.value = PRECISION_UNCACHED;

    resizeVisibleCatsAndInfoFields();
    fWantsFullReload = false;

    alertsData.thresholds.resetOwner(this);
    logger.info("resetAlertsOwner OK");

    detectFullLimitHit();
    logger.info("Detect full limit hit OK");

    logger.info("reimport OUT");
    storeResultIf(L"reimport");
}

void SalesProject::storeResultIf(const wchar_t* aAction) const
{
    if (im::globalLogParams.storeResult) {
        auto params = ProjectSavingParams{
            .newPath = importLogsPath + L"!" + aAction + EXT_MINE,
            .savingPolicy = SavingPolicy::SaveAs
        };
        saveToFile(params);
    }
}

void SalesProject::storeResultIf(std::optional<std::filesystem::path> path) const
{
    if (path.has_value()) {
        auto params = ProjectSavingParams{
            .newPath = *path / "imported.gsl",
            .savingPolicy = SavingPolicy::SaveAs
        };
        saveToFile(params);
    }
}

std::unique_ptr<ReimportTemp> reimportToTemp(
    const SalesProject::InfoForReimport& projectInfo, im::MultipleImporters& aImporters,
    const dt::Date& aThreshold, UpdateType updateType, im::log::LogsBundleId logsId
)
{
    size_t nMaxPoints = getMaxNDates(aImporters);
    return reimportToTemp(projectInfo, aImporters, nMaxPoints, aThreshold, updateType, logsId);
}

void SalesProject::convertCostsToPrices()
{
    // std::cout << "convertCostsToPrices IN" << std::endl;
    for (auto chan = allChannels().begin(); chan != allChannels().end(); ++chan) {
        for (ChannelPoint& pt : chan->realChannel) {
            pt.convertCostToPrice();
        }
    }
}

void SalesProject::doClear(size_t anMaxPoints)
{
    clearMemory();

    fMap->clear();

    fRealPoints.assign(anMaxPoints, RealPoint(dt::Date::ZERO, NO_ARCHIVE));

    precisionCache.value = PRECISION_UNCACHED;
    sets = ProjectSettings::DFLT;
    fKeyDates = im::KeyDates::ZERO;
    fWantsFullReload = false;

    itsShelfLifeUnit = ShelfLifeUnit::PERIOD;
    fContainsSnailInfo = false;

    fInTransitionStorageManager.clear();
    fSubstitutionsStorageManager.clear();
    inventoryCollector().clear();
    fSuppliersStorage.clear();

    fDashboardSettings.clear();

    dropLimitHit();

    clearAlerts();
}

const ChannelSet& SalesProject::allChannelNames() const
{
    return fMap->allChannelNames();
}

dt::TimePrecision SalesProject::calcTrueDatePrecision() const
{
    dt::TimePrecision precision = dt::tpCoarseMost;
    FOR_S(t, 0, nRealPoints()) {
        precision = std::max(precision, realPoints(t).date.truePrecision());
    }
    return precision;
}

dt::TimePrecision SalesProject::trueDatePrecision() const
{
    if (precisionCache.value == PRECISION_UNCACHED) {
        switch (imManager.dateProgression(fIsConnector2).unit) {
        case im::DateProgression::Unit::DAY:
        case im::DateProgression::Unit::WEEK:
            precisionCache.value = dt::TimePrecision::tpDay;
            break;
        case im::DateProgression::Unit::MONTH:
            precisionCache.value = dt::TimePrecision::tpMonth;
            break;
        default: precisionCache.value = dt::TimePrecision::tpCoarseMost;
        }
        precisionCache.value = std::max(precisionCache.value, calcTrueDatePrecision());
    }
    return precisionCache.value;
}

namespace {

    constexpr uint32_t signature = 0x8b8d6dbc;

    enum {
        opHeader = 1,
        opHeaderV2 = 350,
        opCurrency = 72,
        opLastTransaction = 107,
        opFirstDubiousTransaction = 231,
        opOldestLastTransaction = 299,
        opLastPoint = 61,
        opInventorySettings = 28,
        dirInventoryColumns = st::DIR2(203),
        dirCommonColumns = st::DIR2(197),
        opCommonColumn = 200,
        dirItemCatColumns = st::DIR2(198),
        opItemCatColumn = 201,
        dirInfoFieldColumns = st::DIR2(199),
        opInfoFieldColumn = 202,
        dirOrdersColumns = st::DIR2(204),
        opOrdersColumn = 206,
        dirOrdersInfoFieldColumns = st::DIR2(453),
        opOrdersInfoFieldColumn = 454,
        dirDCColumns = st::DIR2(195),  /// deleted february 2023
        dirIntersiteColumns = st::DIR2(321),
        dirForecastColumns = st::DIR2(196),
        dirDemandRows = st::DIR2(314),
        dirDemandVisibleRows = st::DIR2(315),
        opDemandRow = 316,
        dirDemandForecastVersions = st::DIR2(317),
        opDemandForecastVersions = 318,
        opListViewSettings = 54,
        opSeasonalThreshold = 75,
        //        opDistributionSettings1 = 63, BROKEN summer 2020
        opDistributionSettings2 = 62,
        opInventoryOptSettings = 181,
        opShelfLifeInDays = 110,
        //        opLocChannel = 90, dropped
        opAbcSettings1 = 81,
        opAbcSettings2 = 91,
        opTreeSettings = 82,
        opHideDistortions = 83,
        opItemCatHeader = 18,
        opLocationCatHeader = 19,
        opAuxFieldHeader = 20,
        opArrivalAuxFieldHeader = 457,
        opBackorderAuxFieldHeader = 459,
        opChannelCatHeader = 329,
        opRequestFullReload = 59,
        // opAllowance32_old = 108,      BROKEN Mar 2021
        dirCultures = st::DIR2(39),
        dirCulture = st::DIR2(40),
        opCulture = 41,
        opTimePoints = 2,
        // opKnownPoints = 44,           BROKEN Mar 2021, upgraded ≈v5
        dirItemRepls = st::DIR2(13),
        opBanItem = 14,
        opReplaceItem = 55,
        opSubstitutions_overrides = st::DIR2(376),
        opSubstitutionsSource_override = 377,
        opSubstitutionsTarget_override = 378,
        opSubstitutionsMultiplier_override = 379,
        opSubstitutionsDescription_override = 380,
        opSubstitutionsRuleStartDate_override = 381,
        // dirCatRepls = 15,         // dropped — unused
        //   opBanCat = 16,
        dirImport = st::DIR2(11),
        dirItems = st::DIR2(17),
        dirItem = st::DIR2(3),
        opItemInfo = 5,
        opItemPerDimension = 88,
        opItemPallet = 332,
        // opItemSupplierCode_Old = 53,  BROKEN 2018
        opItemAuxFields = 21,
        opItemAuxFieldsOverride = 35,
        // opItemServiceLevelPm = 65,    BROKEN 2018
        // opItemShelfDiscardPc = 68,    BROKEN 2018
        // opItemNPeriods = 100,         BROKEN 2018
        opItemFlags = 76,
        dirSubcat = st::DIR2(4),
        opCatName = 23,
        opCatId = 216,
        opInsulate = 24,
        dirLocations = st::DIR2(18),
        dirLocation = st::DIR2(6),
        opLocationInfo = 7,
        opLocationDescription = 120,
        opTransferRegion = 183,
        dirLocationInfoOverrides = st::DIR2(415),
        opTransferRegionOverride = 416,
        dirChannelCats = st::DIR2(325),  ///< also dubbed as subdir of dirChannelSubcats
        opChannelCatId = 326,
        opChannelCatName = 327,
        dirChannelHierSets = st::DIR2(335),
        dirChannelSubcats = st::DIR2(328),
        dirChannels = st::DIR2(124),
        dirChannel = st::DIR2(125),
        dirEntries = st::DIR2(19),
        dirEntry = st::DIR2(8),
        opEntryInfo = 9,
        opEntryExternalDistribCenter = 205,
        opEntryDistribOverride = 208,
        opEntryDistribCenter = 111,
        opEntrySupplierCode = 73,
        opEntryPurchaseGroupId = 228,
        opEntryPurchaseGroupIdOverride = 229,
        opEntryManufactureGroupId = 312,
        opEntryManufactureGroupIdOverride = 313,
        opEntrySupplierItemCode = 106,
        opEntryCurrency = 74,
        opEntryInventory = 58,
        dirEntryDynamicMaxBundle = st::DIR2(268),
        opDynamicMaxBundle = 269,
        opEntryShelfLife = 66,
        opEntrySafetyShelf = 112,
        opEntryLeadTimeVariance = 69,
        opEntryPurchasePrice = 70,
        opEntryBalancePrice = 71,
        opEntryReal = 10,
        opEntryReal_v2 = 331,  // extended Nov 2022
        opEntryOverride = 12,
        opEntryOverride_v2 = 330,  // extended Nov 2022
        // opEntryOnHand_v1 = 24,                // BROKEN Mar 2021, upgraded long ago
        // opEntryOnHandOverride_v1 = 25,        // BROKEN Mar 2021, upgraded long ago
        // opEntryOnOrderOverride_v1 = 29,       // it’s better to drop
        dirEntryModels = st::DIR2(26),
        dirEntryModel = st::DIR2(27),
        // dirEntryModels_v2 = st::DIR2(43),     // next version was made on V1=26 and is actually
        // BROKEN
        opEntryMiscOverride = 30,
        opEntryLastPlace = 119,
        opEntryOnHand = 32,
        opEntryOnHandOverride = 33,
        opEntryAvgOnHand = 105,
        opEntryOnOrderOverride = 34,
        opEntryOnOrderDateOverride = 60,
        opEntryLostDays = 82,
        opEntryLostDaysOverride = 83,
        // opEntryApprovalState_v1_old = 36,     // BROKEN Mar 2021, upgraded ≈v5
        // opEntryApprovalState_v2_old = 42,
        opEntryPrice = 37,
        opEntryProfit = 92,
        opEntryPriceForecast = 38,
        dirEntryActualNotes = st::DIR2(45),
        dirEntryOnHandNotes = st::DIR2(50),
        // dirEntryActualNote, etc. in this directory
        dirEntryDirectNote = st::DIR2(51),  ///< note attached directly to entry
        dirEntryArrivals
            = st::DIR2(101),  // UPGRADED Aug 2019, BROKEN Mar 2021, used to be fixed arrivals V2
        opArrival = 104,
        opArrival_overrides = st::DIR2(351),
        opArrivalDate_override = 352,
        opArrivalQty_override = 353,
        opArrivalCost_override = 354,
        opArrivalPlaceDate_override = 355,
        opArrivalDocN_override = 356,
        opArrivalOrderType_override = 357,
        opArrivalTransferSource_override = 358,
        opArrivalCurrency_override = 359,
        opArrivalInfoFields = 456,
        // dirEntryLeadTimeArrivals_v2 = st::DIR2(102),   // UPGRADED Aug 2019, BROKEN Mar 2021
        //  opArrival here too
        opEntryBackorder_v2 = 89,  // EXTENDED summer 2020, UPGRADED Mar 2021
        opEntryBackorderOverride = 56,
        dirBackorders_v3 = st::DIR2(233),  // EXTENDED 2 Jul 2020
        opBackorder_v3 = 234,
        opBackorder_overrides = st::DIR2(360),
        opBackorderDate_override = 361,
        opBackorderQty_override = 362,
        opBackorderDocN_override = 363,
        opBackorderInfoFields = 458,
        opEntryServiceLevelPm = 64,
        opEntryShelfDiscardPc = 67,
        opEntrySS_SalesPeriods = 99,
        opEntrySS_BomPeriods = 474,
        opEntrySS_DcPeriods = 475,
        // opEntryBypassDc = 109,    now unused
        dirEntryChannels = st::DIR2(121),
        dirEntryChannel = st::DIR2(122),
        opChannelHeader = 123,
        opChannelAutocreated = 155,
        opChannelCheckState = 170,
        opImportedOutlier = 207,
        opSnailChannelInfo = 233,
        opTopDownCoeffOverride = 237,
        dirExpirations = st::DIR2(162),
        dirExpiration = st::DIR2(163),
        opExpirationDate = 164,
        opBatchOnHand = 167,
        opBatchCode = 168,
        dirOrderCosts = st::DIR2(276),
        dirOrderCost = st::DIR2(277),
        opQty = 278,
        opCost = 279,
        // opEntryPriceBuddies = 77,     now unused
        opHierSets_v1 = 22,  // in both dirItem and opItem          EXTENTED Aug 2021
        opChannelHierSets_v1 = 161,  // to prevent from intersection    EXTENTED Aug 2021
        opPriceHierSets_v1 = 79,  // same as opHierSets
        // opHierSets_v2 = 290,     // BROKE Nov 2023, dropped long ago
        // opChannelHierSets_v2 = 291,  // BROKE Nov 2023, dropped long ago
        //  dirItemPrice = st::DIR2(80), deprecated
        dirGroups = st::DIR2(84),  // suppliers
        dirGroup = st::DIR2(85),  // supplier
        opGroupName = 86,
        opGroupInfo = 87,
        opCustomGroup_overrides = st::DIR2(382),
        opMinWeight_override = 383,
        opMinVolume_override = 384,
        opMinQty_override = 385,
        opMaxQty_override = 386,
        opMinMoney_override = 387,
        opMaxMoney_override = 388,
        // opName_override = 389, deprecated
        // opCustomGroupOverrides = 234, deprecated
        dirCustomMfgGroups = st::DIR2(311),
        dirBom = st::DIR2(98),  // 93 used to be old BoM
        dirBom2 = st::DIR2(94),
        opBomHead = 95,
        opBomManufacturingLocation = 333,
        opBomBatchSize = 113,
        opBomMinBatch = 235,
        opBomMaxBatch = 306,
        opBomMfgLeadTime = 232,
        dirBomResponse = st::DIR2(96),
        opBomResponse = 97,
        dirInventoryFilters = st::DIR2(114),
        dirFilter = st::DIR2(115),
        opFilterHead = 116,
        dirFilterConditions = st::DIR2(117),
        opFilterCondition = 118,
        dirFilterStringParameters = st::DIR2(391),
        opFilterStringParameter = 392,
        // dirEntryPriceChannel = st::DIR2(126), deprecated
        dirArchive = st::DIR2(127),
        dirArchiveInfo = st::DIR2(128),
        opArchivePeriod = 129,
        opArchiveInvVal = 130,
        opArchiveOverstock = 131,
        opArchiveStockout = 132,
        opArchiveDeadInvVal = 133,
        opArchiveTurnover = 134,
        opArchiveMargin = 135,
        opArchiveTurnearn = 136,
        opArchiveRevLast = 137,
        opArchiveRevNext = 138,
        opArchiveSalesLast = 229,
        opArchiveSalesNext = 230,
        opArchivePurchaseVal = 139,
        opArchiveExpectedWriteOffs = 169,
        dirInventoryTabs = st::DIR2(140),
        dirInvTabData = st::DIR2(141),
        opInvTabName = 142,
        dirInvTabFilterConditions = st::DIR2(143),
        opInvTabFilterCondition = 144,
        dirDistribTabs = st::DIR2(145),  // upgraded FEB 2023
        dirDcTabData = st::DIR2(146),  // upgraded FEB 2023
        opDcTabName = 147,  // upgraded FEB 2023
        dirDcTabFilterConditions = st::DIR2(148),  // upgraded FEB 2023
        opDcTabFilterCondition = 149,  // upgraded FEB 2023
        dirDashboardSettings = st::DIR2(150),
        opDashboardIStartDate = 151,
        opDashboardPeriodsCount = 347,
        opDashboardFlags = 152,
        opDashboardComparePeriods = 153,  // that’s OK, we don’t intersect with PartPoints
        opDashboardEnable = 154,  // that’s OK too
        //            opDashboardEnableROI = 176, dropped
        opPartPoints = 153,  // realPoints info about period part
        opLastUpdated = 154,
        dirPromotions = st::DIR2(156),
        dirPromotionsStorage = st::DIR2(467),
        dirPromotionData = st::DIR2(157),
        dirPromotionInfo = st::DIR2(460),
        opPromotionStart = 158,
        opPromotionEnd = 159,
        opPromotionDiscount = 160,
        opPromotionStart_override = 461,
        opPromotionEnd_override = 462,
        opPromoItemCode = 463,
        opPromoLocation = 464,
        opPromoChannel = 465,
        opPromoCreationType = 466,
        // opAllowance32_v1 = 171,              // EXTENDED 2019, BROKEN Mar 2020
        opImportedCloneOf = 172,
        opAllowance32 = 173,
        opChannelAllowance32_v2 = 175,
        dirInventoryOptTabs = st::DIR2(176),
        dirInvOptTabData = st::DIR2(177),
        opInvOptTabName = 178,
        dirInvOptTabFilterConditions = st::DIR2(179),
        opInvOptTabFilterCondition = 180,
        opUseModelState = 181,
        opChannelUseModelState = 182,
        dirForecastTabs = st::DIR2(184),
        opForecastTabType = 186,
        opWantedActuals = 187,
        opSumType = 188,
        opPeriod = 189,
        opDisplayIn = 190,
        opNPeriods = 191,
        opTurnover = 192,
        opFilterOwner = 281,
        opFilterOwnerV2 = 345,
        opEntrySalesPrice = 185,
        opEntryStatus = 193,
        opEntryOrderingDays = 194,
        opEntryWantAdjustModelLevel = 206,
        opEntryWantDemandSensing = 346,
        dirContainers = st::DIR2(209),
        dirContainer = st::DIR2(210),
        opContainerId = 211,
        opContainerParams = 212,
        opCustomContainer_overrides = st::DIR2(393),
        opWeight_overrides = 394,
        opVolume_override = 395,
        opPallet_override = 396,
        opQty_override = 397,
        opOrderingCost_override = 398,
        opMaxCount_override = 399,
        opEntryContainerId = 213,
        opEntryContainerIdOverride = 214,
        opContainerSets = 215,
        dirCustomContainers = st::DIR2(216),
        dirPermissions = st::DIR2(218),
        dirPermissionData = st::DIR2(219),
        dirItemCatsPermission = st::DIR2(220),
        dirItemsPermission = st::DIR2(221),
        dirLocationCatsPermission = st::DIR2(222),
        dirLocationsPermission = st::DIR2(223),
        dirChannelsPermissionV1 = st::DIR2(224),
        dirChannelsPermissionV2 = st::DIR2(455),  // extended 15.12.23
        dirChannelCatsPermission = st::DIR2(334),
        opPermission = 225,
        opPermissionId = 226,
        opPermissionName = 249,
        opPermissionDesc = 262,
        opPermissionAllChannels = 301,  // EXTENDED Jan 2023
        opPermissionCounter = 227,
        opSavedWithVersion = 228,
        opElasticityCorrelationThreshold = 236,
        dirProjectChangelog = st::DIR2(238),
        dirChangeLine = st::DIR2(239),
        opDescriptionKey = 266,
        opChannelId = 241,
        opTimePoint = 242,
        opCmdIndex_old = 267,
        opCmdIndex = 342,
        opNChannelsAffected = 308,
        dirRoles = st::DIR2(244),
        dirRoleData = st::DIR2(245),
        opConfigProject = 246,
        opUpdateProject = 247,
        opExportOrders = 248,
        dirAvailableTabs = st::DIR2(250),
        opTab = 251,
        opRoleId = 252,
        opRoleName = 253,
        opRoleDesc = 263,
        opRoleCounter = 254,
        dirUsers = st::DIR2(255),
        dirUsersV2 = st::DIR2(344),
        dirUser = st::DIR2(256),
        opUsername = 257,
        opUserId = 260,
        opPassword = 258,
        opSaltHash = 259,
        opUserCounter = 261,
        opLastSeenStamp = 262,
        opUserEmail = 264,
        opFullName = 265,
        dirImportedGroups = st::DIR2(270),
        dirImportedGroup = st::DIR2(271),
        opImportedGroupName = 272,
        opImportedGroupInfo = 273,
        // 266, 267 are for audit changes
        opAutoUpdateSets = 274,
        opAutoExportSets = 275,
        // 276-279 are for ordering costs
        opEntryPurchaseBomItems = 280,
        opImportedOC = 282,
        opOutlier = 283,
        opChannelOutlier = 284,
        opForecastVersionsV1 = 285,
        opEntryDataSource = 286,
        opHierApproval = 287,
        opHierChannelApproval = 288,
        //        opListViewSettings_v2 = 289,  // it was never used in save, so it can be reused!!!
        // 290-291 is for opHierSets_v2 and opChannelHierSets_v2
        opForecastVersion = 292,
        opCustomCurrency = 293,
        opCurveVisibility = 294,
        opMassTopDown = 319,
        dirAlertsSettings = st::DIR2(295),
        opThresholds = 296,
        opEntryImportedModel = 297,
        opOverriddenOutlier = 298,
        opRemOrSubstRules = 299,
        dirChannelRepls = st::DIR2(300),
        dirSeasonalityPatterns = st::DIR2(302),
        opSeasonalityPattern = 303,
        opHierSeasonalityPattern = 304,
        opHierChannelSeasonalityPattern = 305,
        opEditConnection = 306,
        opExportTables = 307,
        opOrdersFilters = 309,
        opFinancialDataRestriction = 310,
        opConfidenceLimitV2 = 320,
        opSalesDataRestriction = 322,
        opPurchasingDataRestriction = 323,
        opProjectUniqueId = 335,
        opModelUniqueId = 336,
        opTenantId = 343,
        opPredictionOverridesStorage = 337,
        opEntryOrderNowOverride = 348,
        opOrderNowOverrideVisibility = 349,
        opFronteggEnv = 364,
        dirForecastVersionsV2 = st::DIR2(365),
        dirStatisticalForecast = st::DIR2(366),
        dirFinalForecast = st::DIR2(367),
        dirAlternativeForecast = st::DIR2(368),
        opAlternativeForecastName = 369,
        dirPermittedUsers = st::DIR2(370),
        dirAccessEntities = st::DIR2(371),
        opAccessEntitiesType = 372,
        opBomAccess = 373,
        opChannelRevenue = 374,
        opApproveForecast = 375,
        // 365 - 372 for forecast versions
        //  337 - 341 are used in formulas
        //  342 is used for changelog
        //  376 - 381 is used ror substitution overrides
        //  382 - 389 is used for custom groups overrides
        opManageForecastVersions = 390,
        // 391 - 392 - are used for filters
        // 393 - 399 - used for custom containers overrides
        opCustomCurrencyV2 = 400,
        opManageUsers = 401,
        dirUserRelatedSettings = st::DIR2(402),
        opDefaultUserSettings = 403,
        dirUsersSettings = st::DIR2(404),
        dirTreeSettings = st::DIR2(405),
        opShowOrder = 406,
        opWantAbc = 407,
        opHideInactive = 408,
        opVisibleItemCats = 409,
        opVisibleLocationCats = 410,
        opVisibleChannelCats = 411,
        dirChartSettings = st::DIR2(412),
        dirViewSettings = st::DIR2(413),
        opWantActualsInListView = 414,
        // 415 - 416 - used for transfer region override
        dirControlData = st::DIR2(417),
        opChosenPeriod = 418,
        opAggregateKeys = 419,
        dirUiSettings = st::DIR2(420),
        opUiSetsTab = 421,
        dirFiltersOrderSettings = st::DIR2(422),
        opFilterSetsTab = 423,
        dirSuppliers = st::DIR2(424),
        dirSupplierData = st::DIR2(425),
        opSupplierId = 426,
        opSupplierName = 427,
        opSupplierItem = 428,
        // opSupplierLocation = 429,
        opSupplierCreationType = 430,
        dirSupplierInvInfo = st::DIR2(431),
        opSupplierLeadTime = 432,
        opSupplierPurchasePrice = 433,
        opSupplierMinLot = 434,
        opSupplierRounding = 435,
        opSupplierCurrency = 436,
        opSupplierMaxLot = 437,
        opAccessSuppliers = 438,
        opEntrySupplierOverride = 439,
        opEntryOrderingDaysOverride = 440,
        dirEphemeral = st::DIR2(441),
        dirEphemeralObject = st::DIR2(442),
        dirEphemeralSetItem = st::DIR2(443),
        dirEphemeralSetLocation = st::DIR2(444),
        dirEphemeralSetChannel = st::DIR2(445),
        opEphemeralAll = 446,
        opEphemeralCategory = 447,
        opEphemeralLeaf = 448,
        opEphemeralChannelAvatar = 449,  // actually leaf, just other format
        dirEphemeralSettings = st::DIR2(450),
        opIsConnector2Project = 451,
        dirExportOrdersManager = st::DIR2(452),
        dirExportReportsManager = st::DIR2(468),
        dirHistoricalOnHandStorage = st::DIR2(469),
        opEntityInfo = 470,
        dirHistoricalOnHandInfo = st::DIR2(471),
        opHistoricalOnHandPoint = 472,
        opDashboardsRightsExtension = 476,
        dirAnalyticsDashboardsStorageSettings = st::DIR2(477),
        dirAnalyticsDashboardSettings = st::DIR2(478),
        opDashboardId = 479,
        opDashboardName = 480,
        opDashboardUiConfig = 481,
        dirAnalyticsWidgets = st::DIR2(482),
        dirAnalyticsWidgetConfig = st::DIR2(483),
        opWidgetId = 484,
        opWidgetName = 485,
        dirWidgetFilter = st::DIR2(486),
        opWidgetFilterCondition = 487,
        dirWidgetDataTypeConfig = st::DIR2(488),
        opWidgetDataType = 489,
        dirWidgetReports = st::DIR2(490),
        dirWidgetReportConfig = st::DIR2(491),
        opReportConfigIndex = 492,
        opSingleMeaningReportType = 493,
        opPeriodicReportType = 494,
        opWidgetChartType = 495,
        opConstrainedSetting = 496,
        opForecastVersionSetting = 497,
        opArchivePeriodSetting = 498,
        opCurrencySetting = 499,

        /**
         * @warn @a 500 is free (Alejandro)
         */

        // Took something → change name to yours!!!
    };

    void writeArchive(st::BlockWriter2& blk, const Archive& archive)
    {
        blk.startDir(dirArchive);
        FOR_S(i, 0, archive.size()) {
            auto& v = archive.infoAt(i);
            blk.startDir(dirArchiveInfo);
            blk.start(opArchivePeriod);
            st::writeDate(blk, v.period);
            if (v.inventoryValue.isSet())
                blk.blockOfIF8(opArchiveInvVal, v.inventoryValue.valueOrNan());
            if (v.overstock.isSet())
                blk.blockOfIF8(opArchiveOverstock, v.overstock.valueOrNan());
            if (v.stockout.isSet())
                blk.blockOfIF8(opArchiveStockout, v.stockout.valueOrNan());
            if (v.deadInventoryValue.isSet())
                blk.blockOfIF8(opArchiveDeadInvVal, v.deadInventoryValue.valueOrNan());
            if (v.turnover.isSet())
                blk.blockOfIF8(opArchiveTurnover, v.turnover.valueOrNan());
            if (v.margin.isSet())
                blk.blockOfIF8(opArchiveMargin, v.margin.valueOrNan());
            if (v.revenueLast.isSet())
                blk.blockOfIF8(opArchiveRevLast, v.revenueLast.valueOrNan());
            if (v.purchaseValue.isSet())
                blk.blockOfIF8(opArchivePurchaseVal, v.purchaseValue.valueOrNan());
            if (v.expectedWriteOffs.isSet())
                blk.blockOfIF8(opArchiveExpectedWriteOffs, v.expectedWriteOffs.valueOrNan());
            blk.endDir();
        }
        blk.endDir();
    }

    void writeDashboardSettings(st::BlockWriter2& blk, const DashboardSettings dashb)
    {
        blk.startDir(dirDashboardSettings);
        blk.start(opDashboardFlags);
        blk.writeID(dashb.flags.numeric());
        blk.start(opDashboardComparePeriods);

        for (const auto& [compareBase, _] : dashb.comparePeriods) {
            st::writeEnum(blk, enumCode(compareBase));
        }

        blk.start(opDashboardEnable);
        blk.writeBool(true);  // in older versions is responsible for enabling the tab
        blk.start(opDashboardPeriodsCount);
        blk.writeID(dashb.nPeriods);
        blk.endDir();
    }

    constexpr static auto halfYearInSeconds
        = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::months{6}).count();

    void writeProjectChangelog(st::BlockWriter2& blk, const std::vector<ChangeLine>& changelog)
    {
        const long long timeUnixNow = dt::utcNow().toUnixTime();
        blk.startDir(dirProjectChangelog);
        for (const auto& changeLine : changelog) {
            if (timeUnixNow - changeLine.timePoint.toUnixTime() > halfYearInSeconds) {
                continue;
            }
            blk.startDir(dirChangeLine);
            for (const auto& [key, wstr] : changeLine.descriptionMap) {
                blk.start(opDescriptionKey);
                blk.writeIStringD(std::string{enumName(key)});
                blk.writeIWstringD(wstr);
            }

            auto affectedChannel = changeLine.affected.channelId();
            if (affectedChannel.has_value()) {
                blk.start(opChannelId);
                blk.writeIWstringD(affectedChannel->item);
                blk.writeIWstringD(affectedChannel->location);
                blk.writeIWstringD(affectedChannel->channel);
            }

            blk.start(opNChannelsAffected);
            blk.writeID(changeLine.affected.count());

            blk.start(opTimePoint);
            st::writeStamp(blk, changeLine.timePoint);

            std::visit(
                utils::Overloaded{
                    [&](const UserId& id) {
                        blk.start(opUserId);
                        blk.writeIStringD(id.string());
                    },
                    [&](const std::string& username) {
                        blk.start(opUsername);
                        blk.writeIStringD(username);
                    },
                    [&](std::monostate) {
                        blk.start(opUsername);
                        blk.writeIStringD(str::empty);
                    }
                },
                changeLine.author
            );

            blk.start(opCmdIndex_old);
            blk.writeIStringD(cmdIndexNameOld(changeLine.executedCommand));

            // EXTENDED 07.02.2023, writing in new and old formats
            // old-style writing can be deleted in ~ half a year
            blk.start(opCmdIndex);
            blk.writeIStringD(enumName(changeLine.executedCommand));

            blk.endDir();  // dirChangeLog
        }
        blk.endDir();  // dirProjectChangesLogs
    }

    void writeAlertsSettings(st::BlockWriter2& blk, const alerts::AllData& alertsData)
    {
        blk.startDir(dirAlertsSettings);
        blk.start(opThresholds);
        blk.writeIF4(alertsData.thresholds.get(ChannelAlerts::MODEL_QUALITY));
        blk.endDir();
    }

    template <class Ovr>
    void writeOvrIf(st::BlockWriter2& blk, uint16_t op, const Ovr& v)
    {
        if (v.isSet()) {
            blk.start(op);
            v.writeTo(blk);
        }
    }

    void writeInventory(st::BlockWriter2& blk, const SmallEntryInfo& aInfo)
    {
        blk.blockOfIWstringDIf(opEntrySupplierCode, aInfo.supplierCode.autoValue);
        blk.blockOfIWstringDIf(opEntrySupplierItemCode, aInfo.supplierItemCode);
        blk.blockOfIWstringDIf(opEntryContainerId, aInfo.containerName.autoValue);
        blk.blockOfIWstringDIf(opEntryContainerIdOverride, aInfo.containerName.overrideValue);
        blk.blockOfIWstringDIf(opEntryCurrency, aInfo.currency);
        blk.blockOfIWstringDIf(opEntryDataSource, aInfo.dataSource);
        blk.blockOfIWstringDIf(opEntryPurchaseGroupId, aInfo.purchaseGroupName.autoValue);
        blk.blockOfIWstringDIf(
            opEntryPurchaseGroupIdOverride, aInfo.purchaseGroupName.overrideValue
        );
        blk.blockOfIWstringDIf(opEntryManufactureGroupId, aInfo.manufactureGroupName.autoValue);
        blk.blockOfIWstringDIf(
            opEntryManufactureGroupIdOverride, aInfo.manufactureGroupName.overrideValue
        );

        blk.start(opEntryInventory);
        aInfo.minBundle.writeTo(blk);
        aInfo.maxBundle.stale.writeTo(blk);
        aInfo.boxRound.writeTo(blk);
        aInfo.rawLeadTime.writeTo(blk);
        aInfo.orderCycle.writeTo(blk);

        writeOvrIf(blk, opEntryShelfLife, aInfo.shelfLife);
        writeOvrIf(blk, opEntryLeadTimeVariance, aInfo.leadTimeVariance);
        writeOvrIf(blk, opEntryPurchasePrice, aInfo.purchasePrice);
        writeOvrIf(blk, opEntryBalancePrice, aInfo.balancePrice);
        writeOvrIf(blk, opEntrySafetyShelf, aInfo.safetyShelf);
        writeOvrIf(blk, opEntrySalesPrice, aInfo.sellPrice);
        blk.start(opEntryStatus);
        st::writeEnum(blk, itemStatusNamesMixed[aInfo.status]);
        blk.start(opEntryImportedModel);

        if (aInfo.isModelActive == IsModelActive::NO) {
            st::writeEnum(blk, itemModelDeprecatedNames[ItemModelDeprecated::ZERO]);
        }
        else {
            st::writeEnum(
                blk, itemModelDeprecatedNames[itemModelToDeprecated(aInfo.importedModel)]
            );
        }

        blk.start(opEntryOrderingDays);
        blk.writeIDOk(aInfo.orderingDays.autoValue.rawValue());

        if (aInfo.orderingDays.isOverridden()) {
            blk.start(opEntryOrderingDaysOverride);
            blk.writeIDOk(aInfo.orderingDays.overrideValue.rawValue());
        }

        blk.start(opEntryWantAdjustModelLevel);
        st::writeEnum(blk, enumCode(aInfo.wantAdjustLevel));

        blk.start(opEntryWantDemandSensing);
        st::writeEnum(blk, enumCode(aInfo.wantDemandSensing));

        if (!aInfo.maxBundle.dynamic.isEmpty()) {
            blk.startDir(dirEntryDynamicMaxBundle);
            aInfo.maxBundle.dynamic.loop([&blk](size_t t, auto value) {
                blk.start(opDynamicMaxBundle);
                blk.writeID(t);
                value.writeTo(blk);
            });
            blk.endDir();
        }

        blk.start(opEntryPurchaseBomItems);
        st::writeEnum(blk, enumCode(aInfo.purchaseBomItems));

        blk.start(opEntryOrderNowOverride);
        FOR_EC_FULL(i, IsIntersite) {
            blk.writeID(aInfo.orderNowOverrides[i].rawValue());
        }
        blk.blockOfIWstringDIf(opEntrySupplierOverride, aInfo.supplierCode.overrideValue);
    }

    constexpr EcArray<Char4, SeasonalityPatternState> seasonalityPatternNames{
        kv<SeasonalityPatternState::INHERIT>("inhe"), kv<SeasonalityPatternState::CUSTOM>("cust"),
        kv<SeasonalityPatternState::AUTO>("auto")
    };

    struct HierOps
    {
        uint16_t main, useModelCache, approval, seasonalityPattern, deprecatedOutlier;
        static const HierOps DFLT;
    };

    constinit const HierOps HierOps::DFLT{
        .main = opHierSets_v1,
        .useModelCache = opUseModelState,
        .approval = opHierApproval,
        .seasonalityPattern = opHierSeasonalityPattern,
        .deprecatedOutlier = opOutlier,
    };

    void doWriteHierSets(
        st::BlockWriter2& blk, const HierSettings& hsets, UseModelFromState useModelState,
        const HierOps& ops
    )
    {
        blk.start(ops.main);
        st::writeEnum(blk, topDownApproachNames[hsets.topDownApproach]);
        st::writeEnum(blk, itemZeroLostNames[hsets.zeroLost]);

        if (hsets.isModelActive == IsModelActive::NO) {
            st::writeEnum(blk, itemModelDeprecatedNames[ItemModelDeprecated::ZERO]);
        }
        else {
            st::writeEnum(blk, itemModelDeprecatedNames[itemModelToDeprecated(hsets.rqModel)]);
        }

        blk.writeIF4(1);  // multiplier, deprecated 02.23
        st::writeEnum(blk, itemAllowBomNames[hsets.allowBom]);
        blk.writeIWstringD(hsets.cultureName);
        blk.writeIWstringD(hsets.cloneOf);
        blk.writeID(hsets.ignoreDataBefore);
        blk.writeBool(true
        );  // ignoreTrendOnly was removed, should be removed from save along with seasonCoeff
        blk.writeIF4(hsets.seasonCoeff);
        st::writeEnum(blk, itemUsePromoNames[hsets.usePromo]);
        st::writeEnum(blk, itemUsePriceNames[hsets.usePrice]);
        st::writeEnum(blk, wantAdjustLevelNames[hsets.adjustModelLevel]);
        st::writeEnum(blk, ignoreLostDaysNames[hsets.ignoreLostDays]);
        st::writeEnum(blk, isModelActiveNames[hsets.isModelActive]);
        st::writeEnum(blk, wantDemandSensingNames[hsets.demandSensing]);

        // order allowance
        if (hsets.isAllowed == ItemOrderAllowed::CUSTOM) {
            blk.start(opAllowance32);
            blk.writeID(hsets.isOrderAllowed.size());
            hsets.isOrderAllowed.loop(
                [&blk](size_t aKey, const HierSettings::OrderAllowedBits& aValue) {
                    blk.writeID(aKey);
                    blk.writeID(aValue.d.to_ulong());
                }
            );
        }


        blk.start(ops.useModelCache);
        st::writeEnum(blk, useModelFromStateNames[useModelState]);

        if (hsets.approvalHorizonState != ApprovalHorizonState::INHERIT) {
            blk.start(ops.approval);
            blk.writeID(hsets.approvalHorizon);
        }

        if (const auto id = hsets.seasonalityPatternId;
            id.clazz != SeasonalityPatternState::INHERIT)
        {
            blk.start(ops.seasonalityPattern);
            st::writeEnum(blk, seasonalityPatternNames[id.clazz]);
            blk.writeID(id.index);
        }
    }

    void writeHierSets(
        st::BlockWriter2& blk, const HierSource& owner, const CachedThing& thing, const HierOps& ops
    )
    {
        const HierSettings& hsets = owner.getHierSettings(thing.cubeId());
        if (hsets.isSmthDefined()) {
            doWriteHierSets(blk, hsets, thing.cache.useModelState, ops);
        }
    }

    void writeHierSetsInDir(
        st::BlockWriter2& blk, const HierSource& owner, const CachedThing& thing, uint16_t opcode
    )
    {
        const HierSettings& hsets = owner.getHierSettings(thing.cubeId());
        if (hsets.isSmthDefined()) {
            blk.startDir(opcode);
            doWriteHierSets(blk, hsets, thing.cache.useModelState, HierOps::DFLT);
            blk.endDir();
        }
    }

    void writeBackordersV4(
        st::BlockWriter2& blk, uint16_t code, const InTransitionRecordsHolder& backordersHolder
    )
    {
        blk.startDir(code);

        backordersHolder.backorders([&](const BackorderObj& obj) {
            const auto& backorder = obj.backorder;
            blk.start(opBackorder_v3);
            st::writeDate(blk, backorder.date.autoValue);
            blk.writeID(backorder.qty.autoValue.valueOrNan());
            blk.writeIWstringD(backorder.docNumber.autoValue);
            blk.writeIWstringD(backorder.channel);
            st::writeEnum(blk, enumCode(backorder.creationType));
            blk.startDir(opBackorder_overrides);
            if (backorder.date.isOverridden()) {
                blk.start(opBackorderDate_override);
                st::writeDate(blk, backorder.date.activeOverrideValue(dt::Date::ZERO));
            }
            writeOvrIf(blk, opBackorderQty_override, backorder.qty);
            if (backorder.docNumber.isOverridden()) {
                blk.start(opBackorderDocN_override);
                blk.writeIWstringD(backorder.docNumber.overrideValue);
            }
            blk.endDir();

            blk.start(opBackorderInfoFields);
            for (const auto& infoField : backorder.infoFields) {
                blk.writeIWstringD(infoField.autoValue);
                blk.writeIWstringD(infoField.overrideValue);
            }
            return TraverseResult::Continue;
        });
        blk.endDir();
    }

    void writeArrivalsV3(st::BlockWriter2& blk, const InTransitionRecordsHolder& aArrivals)
    {
        blk.startDir(dirEntryArrivals);
        aArrivals.arrivals([&](const ArrivalObj& obj) {
            blk.start(opArrival);
            const auto& v = obj.arrival;

            st::writeDate(blk, v.arrivalDate.autoValue);
            blk.writeID(v.qty.autoValue.valueOrNan());
            blk.writeIF4(v.cost.autoValue.valueOrNan());
            // Optional for V3
            st::writeDate(blk, v.placeDate.autoValue);
            blk.writeIWstringD(v.docNumber.autoValue);
            st::writeEnum(blk, enumCode(v.orderType.autoValue));
            blk.writeIWstringD(v.transferSource.autoValue);
            blk.writeIWstringD(v.currency.autoValue);
            st::writeEnum(blk, enumCode(v.creationType));

            blk.startDir(opArrival_overrides);
            if (v.arrivalDate.isOverridden()) {
                blk.start(opArrivalDate_override);
                st::writeDate(blk, v.arrivalDate.activeOverrideValue(dt::Date::ZERO));
            }
            writeOvrIf(blk, opArrivalQty_override, v.qty);
            writeOvrIf(blk, opArrivalCost_override, v.cost);
            if (v.placeDate.isOverridden()) {
                blk.start(opArrivalPlaceDate_override);
                st::writeDate(blk, v.placeDate.activeOverrideValue(dt::Date::ZERO));
            }
            if (v.docNumber.isOverridden()) {
                blk.start(opArrivalDocN_override);
                blk.writeIWstringD(v.docNumber.overrideValue);
            }
            if (v.orderType.isOverridden()) {
                blk.start(opArrivalOrderType_override);
                st::writeEnum(blk, enumCode(v.orderType.activeOverrideValue(im::OrderType::NONE)));
            }
            if (v.transferSource.isOverridden()) {
                blk.start(opArrivalTransferSource_override);
                blk.writeIWstringD(v.transferSource.overrideValue);
            }
            if (v.currency.isOverridden()) {
                blk.start(opArrivalCurrency_override);
                blk.writeIWstringD(v.currency.overrideValue);
            }
            blk.endDir();

            blk.start(opArrivalInfoFields);
            for (const auto& infoField : v.infoFields) {
                blk.writeIWstringD(infoField.autoValue);
                blk.writeIWstringD(infoField.overrideValue);
            }

            return TraverseResult::Continue;
        });

        blk.endDir();
    }

    void writeSuppliers(st::BlockWriter2& blk, const SuppliersStorage& storage)
    {
        blk.startDir(dirSuppliers);
        storage.traverseAll([&](const Supplier& supplier) {
            blk.startDir(dirSupplierData);

            blk.blockOfStringD(opSupplierId, supplier.id.string());
            blk.blockOfIWstringD(opSupplierName, supplier.name);
            blk.blockOfIWstringD(opSupplierItem, supplier.item);
            blk.start(opSupplierCreationType);
            st::writeEnum(blk, enumCode(supplier.type));

            blk.startDir(dirSupplierInvInfo);

            blk.start(opSupplierLeadTime);
            supplier.invInfo.leadTime.writeTo(blk);
            blk.start(opSupplierPurchasePrice);
            supplier.invInfo.purchasePrice.writeTo(blk);
            blk.start(opSupplierMinLot);
            supplier.invInfo.minLot.writeTo(blk);
            blk.start(opSupplierRounding);
            supplier.invInfo.rounding.writeTo(blk);
            blk.start(opSupplierCurrency);
            blk.writeIWstringD(supplier.invInfo.currency.autoValue);
            blk.writeIWstringD(supplier.invInfo.currency.overrideValue);

            blk.endDir();  // dirSupplierInvInfo

            blk.endDir();  // dirSupplierData

            return TraverseResult::Continue;
        });

        blk.endDir();
    }

    void writeInTransition(st::BlockWriter2& blk, const InTransitionRecordsHolder& aArrivals)
    {
        writeArrivalsV3(blk, aArrivals);
        writeBackordersV4(blk, dirBackorders_v3, aArrivals);
    }

    enum {
        OP_TAB_NAME,
        DIR_TAB_FILTER_CONDITIONS,
        OP_OWNER_ID,
        OP_OWNER_ID_V2,
        OP_TYPE,
        OP_TAB_N = OP_TYPE,
        OP_PERIOD,
        OP_DISPLAY,
        OP_N_PERIODS,
        OP_WANTED_ACTUALS,
        OP_SUM_TYPE,
        OP_TURNOVER,
        OP_FORECAST_VERSION,
        OP_REPORT_TAB_N
    };

    struct ReportTabOps
    {
        const char *sTabName, *sTabFilterCondition;
        uint16_t dirTabs, dirTabsData;
        uint16_t opsInvTab[OP_TAB_N];
        uint16_t opFilterCondition;

        uint16_t opTabName() const { return opsInvTab[OP_TAB_NAME]; }

        uint16_t opOwnerId() const { return opsInvTab[OP_OWNER_ID]; }

        uint16_t opOwnerIdV2() const { return opsInvTab[OP_OWNER_ID_V2]; }

        uint16_t dirFilterConditions() const { return opsInvTab[DIR_TAB_FILTER_CONDITIONS]; }
    };

    struct ForecastTabOps
    {
        const char *sTabName, *sTabFilterCondition, *sForecastToolbar;
        uint16_t dirTabs, dirTabsData;
        uint16_t opsForecastTab[OP_REPORT_TAB_N];
        uint16_t opFilterCondition;

        uint16_t opTabName() const { return opsForecastTab[OP_TAB_NAME]; }

        uint16_t opOwnerId() const { return opsForecastTab[OP_OWNER_ID]; }

        uint16_t opOwnerIdV2() const { return opsForecastTab[OP_OWNER_ID_V2]; }

        uint16_t dirFilterConditions() const { return opsForecastTab[DIR_TAB_FILTER_CONDITIONS]; }

        uint16_t opForecastType() const { return opsForecastTab[OP_TYPE]; }

        uint16_t opWantedActuals() const { return opsForecastTab[OP_WANTED_ACTUALS]; }

        uint16_t opSumType() const { return opsForecastTab[OP_SUM_TYPE]; }

        uint16_t opPeriod() const { return opsForecastTab[OP_PERIOD]; }

        uint16_t opDisplayIn() const { return opsForecastTab[OP_DISPLAY]; }

        uint16_t opNPeriods() const { return opsForecastTab[OP_N_PERIODS]; }

        uint16_t opTurnover() const { return opsForecastTab[OP_TURNOVER]; }

        uint16_t opForecastVersion() const { return opsForecastTab[OP_FORECAST_VERSION]; }
    };

    const ReportTabOps opsInv{
        "Inventory tab name",
        "Inventory tab filter conditions",
        dirInventoryTabs,
        dirInvTabData,
        {opInvTabName, dirInvTabFilterConditions, opFilterOwner, opFilterOwnerV2},
        opInvTabFilterCondition
    };

    const ReportTabOps opsDistrib{
        "DC tab name",
        "DC tab filter conditions",
        dirDistribTabs,
        dirDcTabData,
        {opDcTabName, dirDcTabFilterConditions, opFilterOwner, opFilterOwnerV2},
        opDcTabFilterCondition
    };

    const ReportTabOps opsInvOpt{
        "Inventory optimization tab name",
        "Inventory optimization tab filter conditions",
        dirInventoryOptTabs,
        dirInvOptTabData,
        {opInvOptTabName, dirInvOptTabFilterConditions, opFilterOwner, opFilterOwnerV2},
        opInvOptTabFilterCondition
    };

    // Opcode reusing ws perfectly possible, but somone didn't do that
    const ForecastTabOps opsForecast{
        "Forecast tab name",
        "Forecast tab filter conditions",
        "Forecast toolbar data",
        dirForecastTabs,
        dirInvTabData,
        {opInvTabName, dirInvTabFilterConditions, opFilterOwner, opFilterOwnerV2, opForecastTabType,
          opWantedActuals, opSumType, opPeriod, opDisplayIn, opNPeriods, opTurnover,
          opForecastVersion},
        opInvTabFilterCondition
    };

    template <class ColClass>
    void writeFilterPredicate(st::BlockWriter2& aBlk, const ColPredicateData& pred)
    {
        st::writeEnum(aBlk, logicOpNames[pred.predicate.logicOp]);
        // Key
        aBlk.writeIW(codeOf<ColClass>(static_cast<ColClass>(pred.colMeaning.clazz)));
        aBlk.writeIW(static_cast<uint16_t>(pred.colMeaning.index));
        // Relation
        st::writeEnum(aBlk, filterRelationNames[pred.predicate.relation]);
        // Value
        aBlk.writeIF8(pred.predicate.value.asNumber);
        st::writeDate(aBlk, pred.predicate.value.asDate);
        aBlk.writeIWstringD(utils::combineSeparatedValues(pred.predicate.value.asString, L','));
        /// backward compatibility: extended aug 2023
        aBlk.startDir(dirFilterStringParameters);
        for (const auto& row : pred.predicate.value.asString) {
            aBlk.start(opFilterStringParameter);
            aBlk.writeIWstringD(row);
        }
        aBlk.endDir();
    }

    const EcArray<Char4, FilterAccess> FILTER_ACCESS_NAMES{
        kv<FilterAccess::Private>("prvt"), kv<FilterAccess::Public>("pblc")
    };

    template <class Class, class TabOps>
    void writeTab1(st::BlockWriter2& aBlk, const TabOps& aOps, const OwnedTabData<Class>& v)
    {
        aBlk.blockOfStringD(aOps.opTabName(), v.name);
        aBlk.startDir(aOps.dirFilterConditions());
        FOR_S(i, 0, v.filterData.filter.nPredicates()) {
            const ColPredicateData& pred = v.filterData.filter.predicateAt(i);
            aBlk.start(aOps.opFilterCondition);
            writeFilterPredicate<Class>(aBlk, pred);
        }
        aBlk.endDir();
        if (v.ownerId.has_value()) {
            aBlk.start(aOps.opOwnerIdV2());
            aBlk.writeIStringD(v.ownerId->string());
        }
        else if (v.oldOwnerId.has_value()) {
            aBlk.start(aOps.opOwnerId());
            aBlk.writeIQ(*v.oldOwnerId);
        }
        else {
            aBlk.start(aOps.opOwnerId());
            aBlk.writeIQ(NOT_FOUND);
        }
        st::writeEnum(aBlk, FILTER_ACCESS_NAMES[v.filterData.accessMode]);
    }

    void writeTab(
        st::BlockWriter2& aBlk, const ReportTabOps& aOps, const OwnedTabData<InvColClass>& v
    )
    {
        writeTab1(aBlk, aOps, v);
    }

    constexpr auto STATISTICAL_FORECAST_ROW = 1;
    constexpr auto ADD_FINAL_AND_STATISTICAL_FORECASTS = 2;

    void writeForecastVersion(
        st::BlockWriter2& blk, const ForecastVersionMeaning& forecastVersion,
        const ForecastVersionsStorage& forecastsStorage
    )
    {
        switch (forecastVersion.type) {
        case ForecastVersionType::Final: {
            blk.writeID(MAIN_FORECAST_ROW);
            break;
        }
        case ForecastVersionType::Statistical: {
            blk.writeID(STATISTICAL_FORECAST_ROW);
            break;
        }
        case ForecastVersionType::Alternative: {
            const auto rowIdx
                = forecastsStorage.getRelativeOverrideRow(*RootUser::instance(), forecastVersion);
            if (rowIdx.has_value()) {
                blk.writeID(*rowIdx + ADD_FINAL_AND_STATISTICAL_FORECASTS);
            }
            blk.writeID(MAIN_FORECAST_ROW);
            break;
        }
        }
    }

    void writeTab(
        st::BlockWriter2& aBlk, const ForecastTabOps& aOps, const OwnedTabData<ForecastColClass>& v,
        const ForecastVersionsStorage& forecastsStorage
    )
    {
        writeTab1(aBlk, aOps, v);

        aBlk.start(aOps.opForecastType());
        st::writeEnum(aBlk, forecastReportTypeNames[v.controlsData.type]);

        aBlk.start(aOps.opPeriod());
        aBlk.writeID(v.controlsData.iChosenArchivePeriod);

        aBlk.start(aOps.opDisplayIn());
        st::writeEnum(aBlk, displayInNames[v.controlsData.displayIn]);

        aBlk.start(aOps.opNPeriods());
        aBlk.writeID(v.controlsData.nPeriods);

        aBlk.start(aOps.opWantedActuals());
        aBlk.writeBool(v.controlsData.areActualsRequired);

        aBlk.start(aOps.opSumType());
        st::writeEnum(aBlk, sumTypeNames[v.controlsData.sum]);

        aBlk.start(aOps.opTurnover());
        st::writeEnum(aBlk, enumCode(v.controlsData.turnover));

        aBlk.start(aOps.opForecastVersion());
        writeForecastVersion(aBlk, v.controlsData.forecastVersion, forecastsStorage);
    }

    template <class TD, class TabOps, class... Args>
    void writeReportTab(
        st::BlockWriter2& aBlk, const TabOps& aOps, const CountedVector<TD>& aTabData,
        const Args&... args
    )
    {
        if (!aTabData.empty()) {
            aBlk.startDir(aOps.dirTabs);
            for (auto& v : aTabData) {
                aBlk.startDir(aOps.dirTabsData);
                writeTab(aBlk, aOps, v, args...);
                aBlk.endDir();
            }
            aBlk.endDir();
        }
    }

    void writeReportTabs(
        st::BlockWriter2& aBlk, const CountedVector<OwnedTabData<InvColClass>>& aInvTabData,
        const CountedVector<OwnedTabData<InvColClass>>& aInvOptTabData,
        const CountedVector<OwnedTabData<ForecastColClass>>& aForecastTabData,
        const ForecastVersionsStorage& forecastsStorage
    )
    {
        writeReportTab(aBlk, opsInv, aInvTabData);
        writeReportTab(aBlk, opsInvOpt, aInvOptTabData);
        writeReportTab(aBlk, opsForecast, aForecastTabData, forecastsStorage);
    }

    template <class T>
    void writeBlock(st::BlockWriter2& blk, const T& value);

    template <>
    void writeBlock(st::BlockWriter2& blk, const int& value)
    {
        blk.writeID(value);
    }

    template <>
    void writeBlock(st::BlockWriter2& blk, const std::wstring& value)
    {
        blk.writeIWstringD(value);
    }

    template <>
    void writeBlock(st::BlockWriter2& blk, const ChannelAvatarID& value)
    {
        blk.writeIWstringD(value.channel);
        blk.writeID(value.catId);
    }

    constexpr EcArray<Char4, AccessRights> permissionNames{
        kv<AccessRights::NONE>("NONE"), kv<AccessRights::READ_ONLY>("READ"),
        kv<AccessRights::EDITABLE>("EDIT")
    };

    template <class T>
    void writeObjsPermission(
        st::BlockWriter2& blk, const std::unordered_map<T, AccessRights>& objs, uint16_t dirObjs
    )
    {
        blk.startDir(dirObjs);
        for (auto& [value, type] : objs) {
            blk.start(opPermission);
            st::writeEnum(blk, permissionNames[type]);
            writeBlock(blk, value);
        }
        blk.endDir();
    }

    void readWstringAndFilterOut(st::Stream& reader, std::wstring& dest)
    {
        reader.readIWstringD(dest);
        if (str::containsXmlUnsupportableChars(dest)) {
            dest = str::filterOutXmlUnsupportableChars(dest);
        }
    }

    template <class T>
    T readBlock(st::BlockReader2& blk);

    template <>
    int readBlock(st::BlockReader2& blk)
    {
        return blk.readID();
    }

    template <>
    std::wstring readBlock(st::BlockReader2& blk)
    {
        std::wstring tmp;
        readWstringAndFilterOut(blk, tmp);
        return tmp;
    }

    template <>
    ChannelAvatarID readBlock(st::BlockReader2& blk)
    {
        std::wstring tmp;
        readWstringAndFilterOut(blk, tmp);
        return {.channel = std::move(tmp), .catId = blk.readID()};
    }

    template <class T>
    std::unordered_map<T, AccessRights> readObjsPermission(st::Order2& aOrd, uint16_t dirObjs)
    {
        if (aOrd.nextInOrder(dirObjs)) {
            st::BlockReader2& blk = aOrd.slave;
            blk.enterDir();
            std::unordered_map<T, AccessRights> r;
            while (blk.waitForBlock(opPermission)) {
                auto type = st::readEnum(blk, permissionNames, AccessRights::NONE);
                r[readBlock<T>(blk)] = type;
            }
            blk.leaveDir();
            return r;
        }
        return {};
    }

    using OldChannelLeavesPermissions = std::unordered_map<std::wstring, AccessRights>;
    using NewChannelLeavesPermissions = std::unordered_map<ChannelAvatarID, AccessRights>;

    OldChannelLeavesPermissions convertToOldChannelLeavesPermissions(
        const NewChannelLeavesPermissions& newFormat
    )
    {
        OldChannelLeavesPermissions res;
        res.reserve(newFormat.size());
        for (const auto& [id, rights] : newFormat) {
            res.emplace(id.channel, rights);
        }
        return res;
    }

    NewChannelLeavesPermissions convertToNewChannelLeavesPermissions(
        OldChannelLeavesPermissions&& oldFormat, const SalesProject& project
    )
    {
        NewChannelLeavesPermissions res;
        res.reserve(oldFormat.size());
        project.doTraverseChannelsT([&oldFormat, &res](const FilteredChannel& ch) {
            if (auto oldFindRes = oldFormat.find(ch.channel->channelName());
                oldFindRes != oldFormat.end())
            {
                auto avatar = ch.channel->avatar;
                res.emplace(
                    ChannelAvatarID{
                        .channel = avatar->name(),
                        .catId = avatar->category()->catId()
                    },
                    oldFindRes->second
                );
            }
        });
        return res;
    }

    void writePermissions(
        st::BlockWriter2& blk, const SafeVector<std::shared_ptr<PermissionGroup>>& groups,
        PermissionId idCounter
    )
    {
        if (!groups.empty()) {
            blk.startDir(dirPermissions);
            blk.start(opPermissionCounter);
            blk.writeID(idCounter);
            for (const auto& group : groups) {
                const auto& info = group->getInfo();
                blk.startDir(dirPermissionData);
                blk.start(opPermissionId);
                blk.writeID(static_cast<uint32_t>(info.id));
                blk.start(opPermissionName);
                blk.writeIWstringD(info.name);
                blk.start(opPermissionDesc);
                blk.writeIWstringD(info.desc);
                writeObjsPermission(blk, info.itemMap.cats, dirItemCatsPermission);
                writeObjsPermission(blk, info.itemMap.leafs, dirItemsPermission);
                writeObjsPermission(blk, info.locationMap.cats, dirLocationCatsPermission);
                writeObjsPermission(blk, info.locationMap.leafs, dirLocationsPermission);
                // backward compatibility: 18.12.23
                writeObjsPermission(
                    blk, convertToOldChannelLeavesPermissions(info.channelMap.leafs),
                    dirChannelsPermissionV1
                );
                writeObjsPermission(blk, info.channelMap.cats, dirChannelCatsPermission);
                writeObjsPermission(blk, info.channelMap.leafs, dirChannelsPermissionV2);
                blk.endDir();
            }
            blk.endDir();
        }
    }

    SafeVector<std::shared_ptr<PermissionGroup>> readPermissions(
        st::Order2& aOrd, IdCounter<VirtualPermission::Id>& rIdCounter, bool hasNontrivialLoc,
        size_t locRootCatId, size_t channelRootCatId, const SalesProject& project
    )
    {
        if (aOrd.nextInOrder(dirPermissions)) {
            SafeVector<std::shared_ptr<PermissionGroup>> r;

            st::BlockReader2& blk = aOrd.slave;
            blk.enterDir();
            blk.getBlock();
            rIdCounter.setIdCounter(blk.readID());
            while (blk.waitForBlock(dirPermissionData)) {
                blk.enterDir();
                static const uint16_t ordPermissions[]
                    = {opPermissionId,           opPermissionName,        opPermissionDesc,
                       dirItemCatsPermission,    dirItemsPermission,      dirLocationCatsPermission,
                       dirLocationsPermission,   dirChannelsPermissionV1, opPermissionAllChannels,
                       dirChannelCatsPermission, dirChannelsPermissionV2};

                st::Order2 ord(blk, ordPermissions);

                ord.rqNext(opPermissionId, "Permission id");
                const int id = static_cast<int>(blk.readID());

                ord.rqNext(opPermissionName, "Permission name");
                std::wstring name;
                readWstringAndFilterOut(blk, name);

                ord.rqNext(opPermissionDesc, "Permission description");
                std::wstring desc;
                readWstringAndFilterOut(blk, desc);

                auto itemCats = readObjsPermission<int>(ord, dirItemCatsPermission);
                auto items = readObjsPermission<std::wstring>(ord, dirItemsPermission);
                auto locationCats = readObjsPermission<int>(ord, dirLocationCatsPermission);
                auto locations = readObjsPermission<std::wstring>(ord, dirLocationsPermission);
                auto oldChannelsLeaves
                    = readObjsPermission<std::wstring>(ord, dirChannelsPermissionV1);

                // EXTENDED Jan 2023
                std::optional<AccessRights> allChannelsRights;
                if (ord.nextInOrder(opPermissionAllChannels)) {
                    auto allChannel = st::readEnum(blk, permissionNames, AccessRights::NONE);
                    allChannelsRights.emplace(allChannel);
                }

                auto channelCats = readObjsPermission<int>(ord, dirChannelCatsPermission);
                if (allChannelsRights.has_value()) {
                    channelCats[channelRootCatId] = *allChannelsRights;
                }

                auto channelLeavesPermissionsGetter = [&]() -> NewChannelLeavesPermissions {
                    // checks if present inside
                    auto res = readObjsPermission<ChannelAvatarID>(ord, dirChannelsPermissionV2);
                    if (!res.empty()) {
                        return res;
                    }
                    return convertToNewChannelLeavesPermissions(
                        std::move(oldChannelsLeaves), project
                    );
                };

                PermissionGroupInfo info{
                    .id = static_cast<uint32_t>(id),
                    .itemMap = {std::move(itemCats),     std::move(items)                },
                    .locationMap = {std::move(locationCats), std::move(locations)            },
                    .channelMap = {std::move(channelCats),  channelLeavesPermissionsGetter()},
                    .name = std::move(name),
                    .desc = std::move(desc)
                };

                if (info.locationMap.cats.empty() && info.locationMap.leafs.empty()
                    && hasNontrivialLoc)
                    info.locationMap.cats[locRootCatId]
                        = AccessRights::EDITABLE;  /// fix older ver compatibility

                r.emplace_back(std::make_shared<PermissionGroup>(std::move(info)));
                blk.leaveDir();
            }
            blk.leaveDir();

            return r;
        }

        return {};
    }

    void writeRoles(
        st::BlockWriter2& blk, const SafeVector<std::shared_ptr<Role>>& roles,
        PermissionId idCounter
    )
    {
        // extension block, identifies the project is new and dashboards rights should not be fixed
        blk.emptyBlock(opDashboardsRightsExtension);
        if (!roles.empty()) {
            blk.startDir(dirRoles);
            blk.start(opRoleCounter);
            blk.writeID(idCounter);
            for (auto& role : roles) {
                blk.startDir(dirRoleData);

                blk.start(opRoleId);
                blk.writeID(role->roleId());

                blk.start(opRoleName);
                blk.writeIWstringD(role->roleName());

                blk.start(opRoleDesc);
                blk.writeIWstringD(role->roleDesc());

                blk.start(opConfigProject);
                blk.writeBool(role->mayChangeProjectSets());

                blk.start(opUpdateProject);
                blk.writeBool(role->mayUpdateProject());

                blk.start(opExportOrders);
                blk.writeBool(role->mayExportOrders());

                blk.startDir(dirAvailableTabs);
                FOR_EC_FULL(i, Tabs)
                    if (role->getInfo().tabAccess[i] >= AccessRights::READ_ONLY) {
                        blk.start(opTab);
                        st::writeEnum(blk, enumCode(i));
                        st::writeEnum(blk, permissionNames[role->getInfo().tabAccess[i]]);
                    }
                blk.endDir();

                blk.start(opRemOrSubstRules);
                blk.writeBool(role->mayRemoveOrSubstituteItems());

                blk.start(opEditConnection);
                blk.writeBool(role->mayEditConnection());

                blk.start(opExportTables);
                blk.writeBool(role->mayExportTables());

                blk.start(opBomAccess);
                blk.writeBool(role->mayAccessBom());

                blk.start(opApproveForecast);
                blk.writeBool(role->mayApproveForecast());

                /// Previously, role had only the "Hide financial data" option.
                /// We have split this option into "Hide sales data" and "Hide purchasing data",
                /// but we want to open our projects correctly on the old version of streamline
                /// @todo Should be removed in the future
                blk.start(opFinancialDataRestriction);
                blk.writeBool(
                    !role->canInteractWithSalesData() || !role->canInteractWithPurchasingData()
                );

                blk.start(opSalesDataRestriction);
                blk.writeBool(!role->canInteractWithSalesData());

                blk.start(opPurchasingDataRestriction);
                blk.writeBool(!role->canInteractWithPurchasingData());

                blk.start(opManageForecastVersions);
                blk.writeBool(role->mayManageForecastVersions());

                blk.start(opManageUsers);
                blk.writeBool(role->mayManageUsers());

                blk.start(opAccessSuppliers);
                blk.writeBool(role->mayAccessSuppliers());

                blk.endDir();
            }
            blk.endDir();
        }
    }

    /// @brief enum used to read deprecated tabs-raelated things
    enum class DeprecatedTabs {
        DC,
        MULTIUSER,
        NN
    };

    constexpr EcArray<Char4, DeprecatedTabs> deprecatedTabsNames{
        PairwiseTempInit::INST, Char4(NoValue::INST),
        kv<DeprecatedTabs::DC>("DCEN"),  // Upgraded February 2023
        kv<DeprecatedTabs::MULTIUSER>("MULT")  // Upgraded August 2023
    };

    SafeVector<std::shared_ptr<Role>> readRoles(
        st::Order2& aOrd, IdCounter<VirtualRole::Id>& rIdCounter
    )
    {
        // if not in order, then prj is kinda old and rights should be extended
        const bool fixupDashboardsRights = !aOrd.nextInOrder(opDashboardsRightsExtension);
        if (aOrd.nextInOrder(dirRoles)) {
            SafeVector<std::shared_ptr<Role>> r;

            st::BlockReader2& blk = aOrd.slave;
            blk.enterDir();
            blk.getBlock();
            rIdCounter.setIdCounter(blk.readID());
            while (blk.waitForBlock(dirRoleData)) {
                blk.enterDir();
                static const uint16_t ordRoles[]
                    = {opRoleId,
                       opRoleName,
                       opRoleDesc,
                       opConfigProject,
                       opUpdateProject,
                       opExportOrders,
                       dirAvailableTabs,
                       opRemOrSubstRules,
                       opEditConnection,
                       opExportTables,
                       opBomAccess,
                       opApproveForecast,
                       opFinancialDataRestriction,
                       opSalesDataRestriction,
                       opPurchasingDataRestriction,
                       opManageForecastVersions,
                       opManageUsers,
                       opAccessSuppliers};
                st::Order2 ord(blk, ordRoles);
                ord.rqNext(opRoleId, "Role id");
                RoleId id = blk.readID();
                RoleInfo newRole;
                newRole.id = id;

                ord.rqNext(opRoleName, "Role name");
                readWstringAndFilterOut(blk, newRole.name);

                ord.rqNext(opRoleDesc, "Role description");
                readWstringAndFilterOut(blk, newRole.desc);

                ord.rqNext(opConfigProject, "Configure project");
                newRole.features.setIf(blk.readB(), Role::Features::CONFIG_PRJ_SETS);

                ord.rqNext(opUpdateProject, "Update project");
                newRole.features.setIf(blk.readB(), Role::Features::UPDATE_PROJECT);

                ord.rqNext(opExportOrders, "Export orders");
                newRole.features.setIf(blk.readB(), Role::Features::EXPORT_ORDERS);

                ord.rqNext(dirAvailableTabs, "Available tabs");
                blk.enterDir();
                while (blk.waitForBlock(opTab)) {
                    // Tabs avTab;
                    // if (st::readEnumOk(blk, enumCodes<Tabs>(), avTab)) {
                    //     AccessRights rights;
                    //     st::readEnumOk(blk, permissionNames, rights, AccessRights::EDITABLE);
                    //     newRole.tabAccess[avTab] = rights;
                    // }

                    // curently read this way for backward compatibility
                    // when it will be broken, use commented code above
                    auto res = st::readPossiblyDeprecatedEnum(
                        blk, enumCodes<Tabs>(), deprecatedTabsNames
                    );
                    if (!res) {
                        continue;
                    }

                    AccessRights rights;
                    st::readEnumOk(blk, permissionNames, rights, AccessRights::EDITABLE);

                    if (res.isActual()) {
                        Tabs tab = res.getActual();
                        newRole.tabAccess[tab] = rights;
                    }
                    else if (res.isDeprecated()) {  /// Upgraded February 2023
                        const auto deprecatedTab = res.getDeprecated();
                        switch (deprecatedTab) {
                        case DeprecatedTabs::DC: {
                            // user had access to dc: give access to Iventory
                            newRole.tabAccess[Tabs::INVENTORY_REPORT]
                                = std::max(rights, newRole.tabAccess[Tabs::INVENTORY_REPORT]);
                            break;
                        }
                        case DeprecatedTabs::MULTIUSER: {
                            // user had access to multiuser tab: it's not a tab anymore, but access
                            // rights should be same
                            newRole.features.setIf(
                                rights >= AccessRights::READ_ONLY, RoleInfo::Features::MANAGE_USERS
                            );
                            break;
                        }
                        default:;
                        }
                    }
                }
                blk.leaveDir();

                // convert editable to read only for old projects
                if (fixupDashboardsRights) {
                    newRole.tabAccess[Tabs::DASHBOARD]
                        = std::min(newRole.tabAccess[Tabs::DASHBOARD], AccessRights::READ_ONLY);
                }

                if (ord.nextInOrder(opRemOrSubstRules)) {
                    newRole.features.setIf(blk.readB(), Role::Features::REMOVAL_SUBST_RULES);
                }

                if (ord.nextInOrder(opEditConnection)) {
                    newRole.features.setIf(blk.readB(), Role::Features::EDIT_CONNECTION);
                }

                if (ord.nextInOrder(opExportTables)) {
                    newRole.features.setIf(blk.readB(), Role::Features::EXPORT_TABLES);
                }

                if (ord.nextInOrder(opBomAccess)) {
                    newRole.features.setIf(blk.readB(), Role::Features::BOM_ACCESS);
                }

                if (ord.nextInOrder(opApproveForecast)) {
                    newRole.features.setIf(blk.readB(), Role::Features::APPROVE_FORECAST);
                }
                else {
                    /// For clients who used older version to not lose ability to  approve forecast
                    newRole.features.setIf(true, Role::Features::APPROVE_FORECAST);
                }

                /// Previously, role had only the "Hide financial data" option.
                /// We have split this option into "Hide sales data" and "Hide purchasing data"
                /// and want to open our old project correctly
                if (ord.nextInOrder(opFinancialDataRestriction)) {
                    const auto hasFinancialDataRestriction = blk.readB();
                    newRole.dataRestrictions.setIf(
                        hasFinancialDataRestriction, Role::DataType::SALES
                    );
                    newRole.dataRestrictions.setIf(
                        hasFinancialDataRestriction, Role::DataType::PURCHASING
                    );
                }

                if (ord.nextInOrder(opSalesDataRestriction)) {
                    newRole.dataRestrictions.setIf(blk.readB(), Role::DataType::SALES);
                }

                if (ord.nextInOrder(opPurchasingDataRestriction)) {
                    newRole.dataRestrictions.setIf(blk.readB(), Role::DataType::PURCHASING);
                }

                if (ord.nextInOrder(opManageForecastVersions)) {
                    newRole.features.setIf(blk.readB(), Role::Features::MANAGE_FORECAST_VERSIONS);
                }

                if (ord.nextInOrder(opManageUsers)) {
                    newRole.features.setIf(blk.readB(), Role::Features::MANAGE_USERS);
                }

                if (ord.nextInOrder(opAccessSuppliers)) {
                    newRole.features.setIf(blk.readB(), Role::Features::ACCESS_SUPPLIERS);
                }

                r.emplace_back(std::make_shared<Role>(std::move(newRole)));

                blk.leaveDir();
            }
            blk.leaveDir();

            return r;
        }

        return {};
    }

    void writeUsersV2(st::BlockWriter2& blk, const Users& users)
    {
        if (users.empty()) {
            return;
        }
        blk.startDir(dirUsersV2);
        for (const auto& user : users.get<ByInsertion>()) {
            blk.startDir(dirUser);

            blk.start(opUserId);
            blk.writeIStringD(user->id().string());

            blk.start(opPermissionId);
            blk.writeID(user->permission()->permissionId());

            blk.start(opRoleId);
            blk.writeID(user->role()->roleId());

            blk.endDir();
        }
        blk.endDir();
    }

    void writeUsers(st::BlockWriter2& blk, const OldUsers& oldUsers)
    {
        const auto& users = oldUsers.get<ByInsertion>();

        if (!users.empty()) {
            blk.startDir(dirUsers);
            blk.start(opUserCounter);
            /// previously there was id counter that was used for generating ids for users before
            /// frontegg but for now this value isn't used, so it doesn't really matter what value
            /// is written here leave it for backward compatibility
            blk.writeID(0);
            for (const auto& user : users) {
                blk.startDir(dirUser);

                blk.start(opUserId);
                blk.writeID(user->userId());

                blk.start(opPermissionId);
                blk.writeID(user->permissionId());

                blk.start(opRoleId);
                blk.writeID(user->roleId());

                blk.start(opUsername);
                blk.writeIStringD(user->username());

                blk.start(opSaltHash);
                blk.writeIStringD(user->password().salt);
                blk.writeIStringD(user->password().hash);

                blk.start(opLastSeenStamp);
                st::writeStamp(blk, user->lastSeen());

                blk.start(opUserEmail);
                blk.writeIStringD(user->email());

                blk.start(opFullName);
                blk.writeIWstringD(user->fullName());

                blk.endDir();
            }

            blk.endDir();
        }
    }

    Users readUsersV2(st::Order2& aOrd, const Permissions& permissions, const Roles& roles)
    {
        if (!aOrd.nextInOrder(dirUsersV2)) {
            return {};
        }
        Users r;

        st::BlockReader2& blk = aOrd.slave;
        blk.enterDir();
        while (blk.waitForBlock(dirUser)) {
            blk.enterDir();
            static const uint16_t ordUsers[] = {opUserId, opPermissionId, opRoleId};

            st::Order2 ord(blk, ordUsers);

            ord.rqNext(opUserId, "User ID");
            std::string id;
            blk.readIStringD(id);
            UserId userId{std::move(id)};

            ord.rqNext(opPermissionId, "Permission ID");
            PermissionId permissionId = blk.readID();

            ord.rqNext(opRoleId, "Role ID");
            RoleId roleId = blk.readID();

            auto role = roles.findById(roleId);
            auto perm = permissions.findById(permissionId);

            r.push_back(std::make_shared<User>(userId, std::move(role), std::move(perm)));

            blk.leaveDir();
        }
        blk.leaveDir();

        return r;
    }

    OldUsers readUsers(st::Order2& aOrd, const Permissions& permissions, const Roles& roles)
    {
        OldUsers res;

        if (aOrd.nextInOrder(dirUsers)) {
            st::BlockReader2& blk = aOrd.slave;
            blk.enterDir();
            blk.getBlock();
            /// leave this for backward compatibility
            std::ignore = blk.readID();
            while (blk.waitForBlock(dirUser)) {
                blk.enterDir();
                static const uint16_t ordUsers[]
                    = {opUserId,   opPermissionId,  opRoleId,    opUsername, opPassword,
                       opSaltHash, opLastSeenStamp, opUserEmail, opFullName};


                st::Order2 ord(blk, ordUsers);

                ord.rqNext(opUserId, "User ID");
                uint32_t userId = blk.readID();

                ord.rqNext(opPermissionId, "Permission ID");
                uint32_t perId = blk.readID();

                ord.rqNext(opRoleId, "Role ID");
                uint32_t roleId = blk.readID();

                std::string username, email, password, salt, hash;
                std::wstring fullname;

                ord.rqNext(opUsername, "Username");
                blk.readIStringD(username);

                bool hasPassword = false;
                if (ord.nextInOrder(opPassword)) {
                    blk.readIStringD(password);
                    hasPassword = true;
                }
                if (ord.nextInOrder(opSaltHash)) {
                    blk.readIStringD(salt);
                    blk.readIStringD(hash);
                }

                dt::Stamp lastSeen;

                if (ord.nextInOrder(opLastSeenStamp)) {
                    lastSeen = st::readStamp(ord.slave);
                }

                if (ord.nextInOrder(opUserEmail)) {
                    blk.readIStringD(email);
                }

                if (ord.nextInOrder(opFullName)) {
                    readWstringAndFilterOut(blk, fullname);
                }

                auto perm = permissions.findById(perId);
                auto role = roles.findById(roleId);

                if (hasPassword) {
                    // Legacy user with plain-text passwords → no performance problems
                    res.emplace_back(std::make_shared<OldUser>(
                        perm, role, std::move(username), email, std::move(fullname),
                        PlainPassword(std::move(password)), lastSeen, userId
                    ));
                }
                else {
                    res.emplace_back(std::make_shared<OldUser>(
                        perm, role, std::move(username), email, std::move(fullname),
                        EncryptedPassword(std::move(salt), std::move(hash)), lastSeen, userId
                    ));
                }

                blk.leaveDir();
            }
            blk.leaveDir();
        }

        return res;
    }

    void blockOfPc(st::BlockWriter2& aBlk, uint16_t aCode, ShelfDiscardInt aPc)
    {
        if (aPc.isSet())
            aBlk.blockOfB(aCode, static_cast<uint8_t>(aPc));
    }

    uint8_t pmToPc(ServiceLevelInt aPm)
    {
        if (!aPm.isSet())
            return std::numeric_limits<uint8_t>::max();
        return clampMin((aPm + 5) / 10, 1, 99);
    }

    uint16_t narrowPmToShort(OverrideablePm::WrappedPm pm)
    {
        if (pm.isSet())
            return static_cast<uint16_t>(pm);
        return std::numeric_limits<uint16_t>::max();
    }

    void blockOfPm(st::BlockWriter2& aBlk, uint16_t aCode, OverrideablePm aPm)
    {
        if (aPm.isSet()) {
            aBlk.start(aCode);
            aBlk.writeB(pmToPc(aPm.overrideValue));
            aBlk.writeIW(narrowPmToShort(aPm.overrideValue));
            aBlk.writeIW(narrowPmToShort(aPm.autoValue));
        }
    }

    class ItemSaver
    {
    private:
        st::BlockWriter2& blk;
        const HierSource& owner;
        void writeCommonItem(const DoubleMap::Item& aItem);
        void writeItem(const DoubleMap::Item& aItem);
        size_t iItem = 0;

    public:
        ItemSaver(st::BlockWriter2& aBlk, const HierSource& aOwner) : blk(aBlk), owner(aOwner) {}

        void recurseCat(const DoubleMap::ItemCat& aCat);
    };

    void ItemSaver::writeCommonItem(const DoubleMap::Item& aItem)
    {
        writeHierSets(blk, aItem.owner(), aItem, HierOps::DFLT);

        blk.blockOfIDIf(opItemFlags, aItem.itemFlags, 0);

        blk.emptyBlock(opItemAuxFields);  // backwards compat.
        if (auto notePtr = aItem.notePtr()) {
            blk.startDir(dirEntryDirectNote);
            utils::saveCommon(*notePtr, blk);
            blk.endDir();
        }
    }

    void ItemSaver::writeItem(const DoubleMap::Item& item)
    {
        blk.startDir(dirItem);

        blk.start(opItemInfo);
        blk.writeIWstringD(item.key());
        blk.writeIWstringD(item.info.description);
        // There were some compatibility values, definitely tear them!
        blk.writeID(0);
        blk.writeID(0);
        blk.writeID(0);
        blk.writeID(0);

        item.temp1 = iItem++;

        if (item.info.unitWeight.isSet() || item.info.unitVolume.isSet()
            || item.info.unitsPerPallet.isSet())
        {
            blk.start(opItemPerDimension);
            blk.writeIF4(item.info.unitWeight.activeAutoValue(0));
            blk.writeIF4(item.info.unitVolume.activeAutoValue(0));
            blk.writeIF4(item.info.unitWeight.overrideValue.valueOrNan());
            blk.writeIF4(item.info.unitVolume.overrideValue.valueOrNan());
            item.info.unitsPerPallet.writeTo(blk);  // extended Dec 2022
        }

        writeCommonItem(item);

        blk.endDir();
    }

    void ItemSaver::recurseCat(const DoubleMap::ItemCat& aCat)
    {
        if (!aCat.parent()) {
            // Root category id
            size_t id = aCat.catId();
            blk.blockOfID(opCatId, id);
        }
        // Save hierarchy settings
        writeHierSets(blk, owner, aCat, HierOps::DFLT);
        blk.emptyBlock(opInsulate);
        // Save items
        for (const auto& [key, item] : aCat.items()) {
            writeItem(*item);
        }
        // Recurse categories
        for (const auto& [key, subcat] : aCat.subcats()) {
            blk.startDir(dirSubcat);
            // Category name
            const std::wstring& catName = subcat.catName();
            blk.blockOfIWstringD(opCatName, catName);
            // Category id
            size_t id = subcat.catId();
            blk.blockOfID(opCatId, id);
            // The rest
            recurseCat(subcat);
            blk.endDir();
        }
    }

    class LocationSaver
    {
    private:
        st::BlockWriter2& blk;
        const HierSource& owner;
        void writeLocation(const DoubleMap::Location& aLocation);
        size_t iLocation = 0;

    public:
        LocationSaver(st::BlockWriter2& aBlk, const HierSource& aOwner) : blk(aBlk), owner(aOwner)
        {}

        void recurseCat(const DoubleMap::LocationCat& aCat);
    };

    void LocationSaver::writeLocation(const DoubleMap::Location& aLocation)
    {
        blk.startDir(dirLocation);

        blk.start(opLocationInfo);
        blk.writeIWstringD(aLocation.key());

        if (!aLocation.info.description.empty())
            blk.blockOfIWstringD(opLocationDescription, aLocation.info.description);
        if (!aLocation.info.transferRegion.autoValue.empty())
            blk.blockOfIWstringD(opTransferRegion, aLocation.info.transferRegion.autoValue);

        aLocation.temp1 = iLocation++;

        writeHierSets(blk, owner, aLocation, HierOps::DFLT);

        /// Write overriden fields
        {
            blk.startDir(dirLocationInfoOverrides);
            if (!aLocation.info.transferRegion.overrideValue.empty()) {
                blk.start(opTransferRegionOverride);
                blk.writeIWstringD(aLocation.info.transferRegion.overrideValue);
            }
            blk.endDir();
        }

        blk.endDir();
    }

    void LocationSaver::recurseCat(const DoubleMap::LocationCat& aCat)
    {
        if (!aCat.parent()) {
            // Root category id
            size_t id = aCat.catId();
            blk.blockOfID(opCatId, id);
        }
        // Save hierarchy settings
        writeHierSets(blk, owner, aCat, HierOps::DFLT);
        blk.emptyBlock(opInsulate);
        // Save locations
        for (const auto& [key, location] : aCat.items()) {
            writeLocation(*location);
        }
        // Recurse categories
        for (const auto& [key, subcat] : aCat.subcats()) {
            blk.startDir(dirSubcat);
            // Category name
            const std::wstring& catName = subcat.catName();
            blk.blockOfIWstringD(opCatName, catName);
            // Category id
            size_t id = subcat.catId();
            blk.blockOfID(opCatId, id);
            // The rest
            recurseCat(subcat);
            blk.endDir();
        }
    }

    const EcArray<Char4, OrderCycleUnit> orderCycleUnitNames{
        kv<OrderCycleUnit::PERIOD>("peri"), kv<OrderCycleUnit::DAY>("day-"),
        kv<OrderCycleUnit::LEADTIME>("lead")
    };

    void writeApproval(st::Stream& st, ChannelCheckState aApp)
    {
        st::writeEnum(st, channelCheckStateNames[aApp]);
    }

    void writePointNoteIf(
        st::BlockWriter2& aBlk, size_t aiPoint, const std::shared_ptr<Note>& aNote
    )
    {
        if (aNote) {
            utils::saveIndexed(*aNote, aBlk, aiPoint);
        }
    }

    template <class Point, class Body>
    void writePointNoteDir(
        st::BlockWriter2& aBlk, uint16_t aCode, const Array1d<Point>& aPoints, const Body& aBody
    )
    {
        aBlk.startDir(aCode);
        FOR_S(iPoint, 0, aPoints.size()) {
            writePointNoteIf(aBlk, iPoint, aBody(iPoint));
        }
        aBlk.endDir();
    }

    void writeCustomVisibleColumns(
        st::BlockWriter2& blk, uint16_t dirCode, uint16_t opCode,
        const SafeVector<bool>& visibleColumns
    )
    {
        blk.startDir(dirCode);
        FOR_S(i, 0, visibleColumns.size()) {
            blk.start(opCode);
            blk.writeBool(visibleColumns[i]);
        }
        blk.endDir();
    }

    template <class Ec>
    void writeVisibleColumns(st::BlockWriter2& blk, const EcArray<bool, Ec>& visibleColumns)
    {
        blk.startDir(dirCommonColumns);
        const auto& colClassNames = enumCodes<Ec>();
        FOR_EC_FULL(i, Ec) {
            if (visibleColumns[i]) {
                blk.start(opCommonColumn);
                st::writeEnum(blk, colClassNames[i]);
            }
            //            blk.writeBool(visibleColumns[i]);
        }
        blk.endDir();
    }

    template <class ColClass>
    void writeVisibleColumnsFull(
        st::BlockWriter2& blk, const EcArray<bool, ColClass>& visibleColumns,
        const EcArray<Char4, ColClass>& colClassNames, uint16_t dirCode, uint16_t opCode
    )
    {
        blk.startDir(dirCode);
        FOR_EC_FULL(i, ColClass) {
            blk.start(opCode);
            st::writeEnum(blk, colClassNames[i]);
            blk.writeBool(visibleColumns[i]);
        }
        blk.endDir();
    }

    void writeReportsColumns(st::BlockWriter2& aBlk, const ForecastReportColumnsSettings& colSets)
    {
        aBlk.startDir(dirForecastColumns);
        writeVisibleColumns(aBlk, colSets.visibleColumns);
        writeCustomVisibleColumns(
            aBlk, dirItemCatColumns, opItemCatColumn, colSets.visibleItemCats
        );
        writeCustomVisibleColumns(
            aBlk, dirInfoFieldColumns, opInfoFieldColumn, colSets.visibleInfoFields
        );
        aBlk.endDir();
    }

    void writeDemandRows(st::BlockWriter2& aBlk, const DemandRowsSettings& rowSets)
    {
        aBlk.startDir(dirDemandRows);
        writeVisibleColumnsFull(
            aBlk, rowSets.visibleRows, enumCodes<demandTab::DemandRowClass>(), dirDemandVisibleRows,
            opDemandRow
        );
        writeCustomVisibleColumns(
            aBlk, dirDemandForecastVersions, opDemandForecastVersions,
            rowSets.visibleAlternativeForecasts
        );
        aBlk.endDir();
    }

    void writeInventoryView(
        st::BlockWriter2& aBlk, uint16_t aColsCode, const InventoryColumnsSettings& invSets
    )
    {
        aBlk.startDir(aColsCode);
        writeVisibleColumns(aBlk, invSets.table.visibleColumns);
        writeCustomVisibleColumns(
            aBlk, dirItemCatColumns, opItemCatColumn, invSets.table.visibleItemCats
        );
        writeCustomVisibleColumns(
            aBlk, dirInfoFieldColumns, opInfoFieldColumn, invSets.table.visibleInfoFields
        );
        writeVisibleColumnsFull(
            aBlk, invSets.plannedOrders.visibleColumns, enumCodes<OrdersColClass>(),
            dirOrdersColumns, opOrdersColumn
        );
        writeCustomVisibleColumns(
            aBlk, dirOrdersInfoFieldColumns, opOrdersInfoFieldColumn,
            invSets.plannedOrders.visibleInfoFields
        );
        aBlk.endDir();
    }

    void writeInventoryViewLegacy(  // for backward compatibility (before user-related sets)
        st::BlockWriter2& aBlk, uint16_t aColsCode, const InventoryTableColumnsSettings& tableSets,
        const PlannedOrdersColumnsSettings* poSets = nullptr
    )  // nullptr here means don't write PO sets
    {
        aBlk.startDir(aColsCode);
        writeVisibleColumns(aBlk, tableSets.visibleColumns);
        writeCustomVisibleColumns(
            aBlk, dirItemCatColumns, opItemCatColumn, tableSets.visibleItemCats
        );
        writeCustomVisibleColumns(
            aBlk, dirInfoFieldColumns, opInfoFieldColumn, tableSets.visibleInfoFields
        );
        if (poSets) {
            writeVisibleColumnsFull(
                aBlk, poSets->visibleColumns, enumCodes<OrdersColClass>(), dirOrdersColumns,
                opOrdersColumn
            );
        }
        aBlk.endDir();
    }

    void writeInventorySettings(
        st::BlockWriter2& aBlk, uint16_t aCode, const ProjectSettings& prjSets,
        const InventorySettings& aSets, const InventoryColumnsSettings& visibilitySets,
        Flags<OrderFilters> aOrderFilters
    )
    {
        const auto& visCols = visibilitySets.table.visibleColumns;

        aBlk.start(aCode);
        aBlk.writeID(aSets.defaultLeadTime.rawValue());
        aBlk.writeID(aSets.defaultOrderCycle);
        aBlk.writeIW(pmToPc(aSets.safetyStock.serviceLevel.pm)
        );  /// @todo [bad] No need in convetring to pc here, as we write in 2 bytes anyway
        aBlk.writeBool(visCols[InvColClass::REMAINDER_I]);
        aBlk.writeBool(visCols[InvColClass::FORECAST_I]);
        aBlk.writeBool(aSets.safetyStock.serviceLevel.enable);
        aBlk.writeBool(std::ranges::any_of(
            aSets.safetyStock.futureSales.nPeriods, &InventorySettings::SafetyStockStatus::enabled
        ));
        aBlk.writeIF4(aSets.safetyStock.futureSales.nPeriods[SafetyStockType::Sales].value);
        aBlk.writeBool(aSets.strategy == OrderStrategy::MINMAX);
        aBlk.writeBool(
            aSets.strategy == OrderStrategy::MINMAX
        );  // They are the same, for compat. reasons
        aBlk.writeBool(visCols[InvColClass::ORDERBY_I]);
        aBlk.writeBool(visCols[InvColClass::BOXROUND]);
        aBlk.writeBool(visCols[InvColClass::MINBUNDLE]);
        aBlk.writeBool(visCols[InvColClass::MAXBUNDLE]);
        st::writeEnum(
            aBlk, orderCycleUnitNames[prjSets.orderCycleUnit]
        );  // backward compatibility, extended on MARCH 23, now its written in readListViewSettings
        aBlk.writeIW(aSets.shelfDiscard);
        aBlk.writeBool(visCols[InvColClass::SHELF_LIFE]);
        aBlk.writeBool(visCols[InvColClass::ORDER_CYCLE]);
        aBlk.writeBool(visCols[InvColClass::SERVICE_LEVEL]);
        aBlk.writeBool(visCols[InvColClass::LEADTIME]);
        aBlk.writeBool(visCols[InvColClass::PURCHASE_PRICE]);
        aBlk.writeBool(visCols[InvColClass::MARGIN]);
        aBlk.writeBool(visCols[InvColClass::TURNEARN]);
        aBlk.writeBool(visCols[InvColClass::NOTE]);
        aBlk.writeBool(visCols[InvColClass::EXCESS_ORDER]);
        aBlk.writeB(prjSets.invView.nActual
        );  // backward compatibility, extended on MARCH 23, now its written in readListViewSettings
        aBlk.writeBool(visCols[InvColClass::DEBT_RECEIVED]);
        aBlk.writeBool(visCols[InvColClass::NET_ORDER]);
        aBlk.writeBool(visCols[InvColClass::PROJECTED_ORDER_DATE]);
        st::writeEnum(
            aBlk, demandViewNames[prjSets.invView.demandView]
        );  // backward compatibility, extended on MARCH 23, now its written in readListViewSettings
        aBlk.writeBool(visCols[InvColClass::SAFETY_SHELF]);
        aBlk.writeIW(aSets.safetyStock.serviceLevel.pm);
        // EXTENDED Jul 2022 for OrderFilters only
        aBlk.writeBool(aOrderFilters.have(OrderFilters::HIDE_FUTURE_ORDERS));
        aBlk.writeBool(aOrderFilters.have(OrderFilters::ACCELERATE_PURCHASE_ORDERS));
        aBlk.writeBool(false);  // removed in march 2023
        aBlk.writeBool(visCols[InvColClass::ITEM_SALES_PRICE]);
        aBlk.writeBool(visCols[InvColClass::ITEM_ORDERING_DAYS]);
        aBlk.writeBool(visCols[InvColClass::BALANCE_PRICE]);
        aBlk.writeBool(aOrderFilters.have(OrderFilters::WANT_ZERO_ORDERS));
        const auto writeSSPeriods = [&aBlk](const InventorySettings::SafetyStockStatus& ssPeriods) {
            aBlk.writeBool(ssPeriods.enabled);
            aBlk.writeIF4(ssPeriods.value);
        };
        writeSSPeriods(aSets.safetyStock.futureSales.nPeriods[SafetyStockType::Sales]);
        writeSSPeriods(aSets.safetyStock.futureSales.nPeriods[SafetyStockType::Dc]);
        writeSSPeriods(aSets.safetyStock.futureSales.nPeriods[SafetyStockType::Bom]);
    }

    bool writeAbcSettings(st::BlockWriter2& aBlk, uint16_t aCode, const ProjectSettings::Abc& aSets)
    {
        if (aSets.isOn()) {
            aBlk.start(aCode);
            st::writeEnum(aBlk, enumCode(aSets.type));
            aBlk.writeB(aSets.scaleBased.pcA);
            aBlk.writeB(aSets.scaleBased.pcB);
            aBlk.writeB(aSets.scaleBased.pcC);
            st::writeEnum(aBlk, enumCode(aSets.func));
            aBlk.writeID(aSets.thresholdBased.pcX);
            aBlk.writeID(aSets.thresholdBased.pcY);
            return true;
        }
        else {
            return false;
        }
    }

    void writeListViewSettings(
        st::BlockWriter2& blk, const ProjectSettings& sets, const ControlsData& controlsData,
        const DemandRowsSettings& demandTableSets, bool isForecastConstrained
    )
    {
        blk.start(opListViewSettings);
        blk.writeBool(controlsData.areActualsRequired
        );  // deprecated since SEP 2023, stored with user-related sets now
        blk.writeBool(sets.showSafetyStockInChart);  // deprecated
        blk.writeIW(sets.kpi.costOfCapital);
        blk.writeBool(sets.kpi.useInTransition);
        st::writeEnum(blk, enumCode(sets.supplyUnit));
        st::writeEnum(blk, enumCode(sets.accuracyMeasure));
        blk.writeBool(sets.enableInventoryOptimization);
        blk.writeBool(sets.wantAllowance);
        blk.writeBool(sets.wantShallowUpdate);
        blk.writeBool(sets.wantKeepApprovals
        );  // EXTENDED Aug 2021: deprecated, so should be removed
        st::writeEnum(blk, enumCode(sets.safetyShelfType));
        blk.writeBool(sets.wantNonStoringDC);
        blk.writeIW(sets.aggregationPeriodStart);
        blk.writeBool(sets.wantKeepCoeffs);
        st::writeEnum(blk, lowInventoryStrategyNames[sets.liStrategy]);
        blk.writeBool(sets.kpi.wantEoq);

        // deprecated, left here for backward compatibility in August 2022
        using R = demandTab::DemandRowClass;
        const auto& visibleRows = demandTableSets.visibleRows;
        blk.writeBool(
            visibleRows[R::UPPER_CONF_LIMIT] || visibleRows[R::LOWER_CONF_LIMIT]
        );  // deprecated, read/write in other place
        blk.writeIF4(sets.upperConfLevel);
        blk.writeIF4(sets.lowerConfLevel);

        blk.writeBool(
            sets.preventOvertakePeriod > 0
        );  // deprecated, left here for backward & forward compatibility in Sep 2022
        blk.writeBool(sets.wantSubtractBackorders
        );  // deprecated, left here for backward compatibility in July 2022
        blk.writeBool(sets.wantPostponeDemand);
        blk.writeBool(sets.wantConstrainBOM);
        blk.writeID(sets.preventOvertakePeriod);
        blk.writeBool(isForecastConstrained);
        blk.writeID(sets.avgSalesPricePeriod);
        st::writeEnum(blk, orderCycleUnitNames[sets.orderCycleUnit]);
        blk.writeB(sets.invView.nActual);
        st::writeEnum(blk, demandViewNames[sets.invView.demandView]);
        blk.writeBool(sets.currentAvgSalesPricePeriodExcluded);

        blk.start(opConfidenceLimitV2);
        blk.writeIF4(sets.upperConfLevel);
        blk.writeIF4(sets.lowerConfLevel);
    }

    void writeTreeSettings(st::BlockWriter2& blk, const ExtendedTreeSettings& treeSets)
    {
        blk.startDir(dirTreeSettings);

        blk.start(opShowOrder);
        st::writeEnum(blk, enumCode(treeSets.mainSets.order));

        blk.blockOfBool(opWantAbc, treeSets.mainSets.wantAbc);
        blk.blockOfBool(opHideInactive, treeSets.hideInactiveNodes);
        blk.blockOfBool(opHideDistortions, treeSets.hideDistortions);

        auto writeVisibleCats = [&](uint16_t opcode, const SafeVector<bool>& cats) {
            blk.start(opcode);
            blk.writeID(cats.size());
            for (bool visibility : cats) {
                blk.writeBool(visibility);
            }
        };

        writeVisibleCats(opVisibleItemCats, treeSets.mainSets.visibleItemCats);
        writeVisibleCats(opVisibleLocationCats, treeSets.mainSets.visibleLocationCats);
        writeVisibleCats(opVisibleChannelCats, treeSets.mainSets.visibleChannelCats);

        blk.endDir();
    }

    void writeChartSettings(st::BlockWriter2& blk, const ChartCurvesSettings& sets)
    {
        blk.startDir(dirChartSettings);
        // it's actually visible curves, not columns))
        writeVisibleColumns(blk, sets.curvesVisiblity);
        blk.endDir();
    }

    void writeAggregateKeys(st::BlockWriter2& blk, std::span<const AggregateKey> aggregateKeys)
    {
        blk.start(opAggregateKeys);
        blk.writeID(aggregateKeys.size());

        for (const auto& agreggateKey : aggregateKeys) {
            st::writeEnum(blk, enumCode(agreggateKey.clazz));
            blk.writeID(agreggateKey.index);
        }
    }

    void writeControlsData(
        st::BlockWriter2& blk, const ControlsData& controlsData,
        const ForecastVersionsStorage& forecastsStorage
    )
    {
        blk.startDir(dirControlData);

        blk.start(opForecastTabType);
        st::writeEnum(blk, forecastReportTypeNames[controlsData.type]);

        blk.start(opChosenPeriod);
        blk.writeID(controlsData.iChosenArchivePeriod);

        blk.start(opDisplayIn);
        st::writeEnum(blk, displayInNames[controlsData.displayIn]);

        blk.start(opSumType);
        st::writeEnum(blk, sumTypeNames[controlsData.sum]);

        blk.start(opForecastVersion);
        writeForecastVersion(blk, controlsData.forecastVersion, forecastsStorage);

        blk.start(opWantedActuals);
        blk.writeBool(controlsData.areActualsRequired);

        blk.start(opNPeriods);
        blk.writeID(controlsData.nPeriods);

        blk.start(opTurnover);
        st::writeEnum(blk, enumCode(controlsData.turnover));

        writeAggregateKeys(blk, controlsData.aggregateKeys);

        blk.endDir();
    }

    void writeUiSettings(
        st::BlockWriter2& blk, const EcArray<TabRelatedUiSettings, UiSetsTabs>& uiSets
    )
    {
        blk.startDir(dirUiSettings);
        FOR_EC_FULL(i, UiSetsTabs) {
            blk.start(opUiSetsTab);
            st::writeEnum(blk, enumCode(i));
            blk.writeIStringD(uiSets[i].columnsWidth.dump());
            blk.writeIStringD(uiSets[i].pinnedColumns.dump());
            blk.writeIStringD(uiSets[i].specific.dump());
        }
        blk.endDir();
    }

    void writeFiltersOrderSettings(
        st::BlockWriter2& blk, const EcArray<FiltersOrdersets, FiltersOrderSetsTabs>& sets
    )
    {
        blk.startDir(dirFiltersOrderSettings);

        FOR_EC_FULL(i, FiltersOrderSetsTabs) {
            blk.start(opFilterSetsTab);

            st::writeEnum(blk, enumCode(i));

            blk.writeID(sets[i].order.size());

            for (const auto val : sets[i].order) {
                blk.writeID(val);
            }
        }
        blk.endDir();
    }

    void writeUserSettings(
        st::BlockWriter2& blk, const UserRelatedSettings& userSettings,
        const ForecastVersionsStorage& forecastsStorage, const UserId* userId = nullptr
    )
    {
        blk.startDir(dirUsersSettings);

        if (userId) {
            blk.blockOfStringD(opUserId, userId->string());
        }

        writeTreeSettings(blk, userSettings.treeSets);

        writeDemandRows(blk, userSettings.demandTableSets);

        writeChartSettings(blk, userSettings.chartSets);

        writeInventoryView(blk, dirInventoryColumns, userSettings.invColSets);
        writeInventoryView(blk, dirIntersiteColumns, userSettings.intersiteColSets);

        writeReportsColumns(blk, userSettings.forecastReportColSets);

        writeDashboardSettings(blk, userSettings.dashboardSets);

        writeControlsData(blk, userSettings.controlsData, forecastsStorage);

        writeUiSettings(blk, userSettings.uiSets);

        writeFiltersOrderSettings(blk, userSettings.filtersOrderSets);

        blk.endDir();
    }

    void writeUserRelatedSettings(
        st::BlockWriter2& blk, const UsersSettingsStorage& usersSettings,
        const ForecastVersionsStorage& forecastsStorage
    )
    {
        if (usersSettings.empty()) {
            return;
        }

        blk.startDir(dirUserRelatedSettings);

        blk.start(opDefaultUserSettings);
        writeUserSettings(blk, usersSettings.getDefaultSets(), forecastsStorage);

        usersSettings.traverseConst([&blk, &forecastsStorage](const auto& pair) {
            const UserId& userId = pair.first;
            const UserRelatedSettings& userSettings = pair.second;

            writeUserSettings(blk, userSettings, forecastsStorage, &userId);
        });

        blk.endDir();
    }

    template <auto clazz>
    void writeReportConfig(
        const ForecastVersionsStorage& forecastsStorage, st::BlockWriter2& blk, unsigned idx,
        const analytics::ReportsConfig<clazz>& config
    )
    {
        using namespace analytics;

        blk.startDir(dirWidgetReportConfig);

        blk.blockOfID(opReportConfigIndex, idx);

        if constexpr (std::is_same_v<
                          std::decay_t<decltype(config.type)>, SingleMeaningDashboardType>)
        {
            blk.start(opSingleMeaningReportType);
        }
        else {
            blk.start(opPeriodicReportType);
        }

        st::writeEnum(blk, enumCode(config.type));

        blk.start(opWidgetChartType);
        st::writeEnum(blk, enumCode(config.chartType));

        using Sets = std::decay_t<decltype(config.sets)>;

        if constexpr (ContainsSetting<ConstrainedSetting, Sets>{}) {
            blk.blockOfB(opConstrainedSetting, get<ConstrainedSetting>(config.sets).state);
        }

        if constexpr (ContainsSetting<ForecastVersionSetting, Sets>{}) {
            blk.start(opForecastVersionSetting);
            writeForecastVersion(
                blk, get<ForecastVersionSetting>(config.sets).meaning, forecastsStorage
            );
        }

        if constexpr (ContainsSetting<ArchivePeriodSetting, Sets>{}) {
            blk.blockOfID(opArchivePeriodSetting, get<ArchivePeriodSetting>(config.sets).period);
        }

        if constexpr (ContainsSetting<CurrencySetting, Sets>{}) {
            blk.blockOfIWstringD(opCurrencySetting, get<CurrencySetting>(config.sets).currency);
        }

        blk.endDir();
    }

    void writeAnalyticsDashboardSettings(
        const ForecastVersionsStorage& forecastsStorage, st::BlockWriter2& blk,
        const analytics::Dashboard& dashboard
    )
    {
        using namespace analytics;

        blk.startDir(dirAnalyticsDashboardSettings);

        blk.blockOfStringD(opDashboardId, dashboard.id.string());
        blk.blockOfIWstringD(opDashboardName, dashboard.name);
        blk.blockOfStringD(opDashboardUiConfig, dashboard.sectionUiConfig.dump());

        blk.startDir(dirAnalyticsWidgets);

        std::ranges::for_each(
            dashboard.widgets,
            [&blk, &forecastsStorage](const analytics::Widget& widget) {
                blk.startDir(dirAnalyticsWidgetConfig);

                blk.blockOfStringD(opWidgetId, widget.id.string());
                blk.blockOfIWstringD(opWidgetName, widget.config.name);

                {
                    const auto& filter = widget.config.filter;
                    blk.startDir(dirWidgetFilter);
                    FOR_S(i, 0, filter.nPredicates()) {
                        blk.start(opWidgetFilterCondition);
                        writeFilterPredicate<ForecastColClass>(blk, filter.predicateAt(i));
                    }
                    blk.endDir();  // filter
                }

                {
                    blk.startDir(dirWidgetDataTypeConfig);
                    // common block
                    visit(
                        widget.config.dataTypeConfig,
                        [&blk, aggrKeysEditable = aggregateKeysEditable(widget.config.dataTypeConfig
                               )](const auto& config) {
                            blk.start(opWidgetDataType);
                            st::writeEnum(blk, enumCode(config.dataType));
                            if (aggrKeysEditable) {
                                writeAggregateKeys(blk, config.keys);
                            }
                        }
                    );

                    blk.startDir(dirWidgetReports);

                    visit(
                        widget.config.dataTypeConfig,
                        [&](const DataTypeGenericConfig<WidgetDataType::Comparative>& config) {
                            for (unsigned idx = 0; idx < config.reports.size(); ++idx) {
                                visit(config.reports[idx], [&](const auto& config) {
                                    writeReportConfig(forecastsStorage, blk, idx, config);
                                });
                            }
                        },
                        [&](const auto& config) {
                            visit(config.report, [&](const auto& config) {
                                writeReportConfig(forecastsStorage, blk, 0, config);
                            });
                        }
                    );

                    blk.endDir();  // widgetReports

                    blk.endDir();  // widget data type config;
                }
                blk.endDir();  // widget config
            }
        );

        blk.endDir();  // widgets

        blk.endDir();  // dashboard
    }

    void writeAnalyticsDashboardsStorageSettings(
        st::BlockWriter2& blk, const analytics::DashboardSettingsStorage& storage,
        const ForecastVersionsStorage& forecastsStorage
    )
    {
        if (storage.empty()) {
            return;
        }

        blk.startDir(dirAnalyticsDashboardsStorageSettings);

        storage.traverse([&](const analytics::Dashboard& dashboard) {
            writeAnalyticsDashboardSettings(forecastsStorage, blk, dashboard);
        });

        blk.endDir();
    }

    // deprecated since FEB 2024, stored in PromotionStorage on SalesProject level
    // left here for backward compatibility
    void writePromotions(st::BlockWriter2& blk, const SalesChannel& aChannel)
    {
        blk.startDir(dirPromotions);
        auto data
            = aChannel.owner()
                  .promotionsStorage()
                  .getPromotionDataByChannel(aChannel.channelId(), promo::NeedOnlyImported::Yes)
                  .data;
        for (auto& promo : data) {
            blk.startDir(dirPromotionData);
            blk.start(opPromotionStart);
            st::writeDate(blk, promo.startDate.autoValue);
            blk.start(opPromotionEnd);
            st::writeDate(blk, promo.endDate.autoValue);
            blk.blockOfIF8(opPromotionDiscount, promo.discount.activeAutoValue(0));
            blk.endDir();
        }
        blk.endDir();
    }

    void writeChannelPart1(st::BlockWriter2& blk, const SalesChannel& aChannel)
    {
        const size_t nRealPoints = aChannel.owner().nRealPoints();

        blk.start(opEntryReal_v2);
        FOR_S(iPoint, 0, nRealPoints) {
            blk.writeIF8(aChannel.realChannel[iPoint].actual.autoValue.valueOrNan()
            );  // extended 10.2022
        }

        blk.start(opEntryReal);
        FOR_S(iPoint, 0, nRealPoints) {
            blk.writeIF4(aChannel.realChannel[iPoint].actual.autoValue.valueOrNan());
        }

        if (aChannel.isAutocreated)
            blk.emptyBlock(opChannelAutocreated);
    }

    void writeChannelPart2(st::BlockWriter2& blk, const SalesChannel& channel)
    {
        if (channel.isActualOverridden()) {
            const size_t nRealPoints = channel.owner().nRealPoints();

            blk.start(opEntryOverride_v2);
            FOR_S(iPoint, 0, nRealPoints) {
                blk.writeIF8(channel.realChannel[iPoint].actual.overrideValue.valueOrNan()
                );  // extended 10.2022
            }

            blk.start(opEntryOverride);
            FOR_S(iPoint, 0, nRealPoints) {
                blk.writeIF4(channel.realChannel[iPoint].actual.overrideValue.valueOrNan());
            }
        }
    }

    void writeChannelPart3(st::BlockWriter2& blk, const SalesChannel& aChannel)
    {
        if (aChannel.hasActualNotes()) {
            writePointNoteDir(
                blk, dirEntryActualNotes, aChannel.realChannel,
                [&aChannel](size_t i) -> const std::shared_ptr<Note>& {
                    return aChannel.realChannel[i].actualNote;
                }
            );
        }
    }

    // value that was used for ApprovalStatus::APPROVED in old versions
    constexpr Char4 oldApprovalText{"appr"};

    constinit const HierOps part4Ops{
        .main = opChannelHierSets_v1,
        .useModelCache = opChannelUseModelState,
        .approval = opHierChannelApproval,
        .seasonalityPattern = opHierChannelSeasonalityPattern,
        .deprecatedOutlier = opChannelOutlier,
    };

    void writeChannelPart4(
        st::BlockWriter2& blk, const SalesChannel& aChannel,
        PredictionOverridesSaver& overridesSaver
    )
    {
        writeHierSets(blk, aChannel.owner(), aChannel, part4Ops);

        const size_t nRealPoints = aChannel.owner().nRealPoints();
        if (aChannel.hasChannelCheckState()) {
            blk.start(opChannelCheckState);
            // enum here, so OK despite poor code
            writeApproval(blk, aChannel.channelCheckState);
        }
        else if (aChannel.hasApprovedPrediction()) {
            // left here for backward compatibility with old approvals
            // EXTENDED Aug 2021
            blk.start(opChannelCheckState);
            blk.write(oldApprovalText.data(), 4);
        }

        if (aChannel.hasDynamicHistoricalPrice()) {
            blk.start(opEntryPrice);
            FOR_S(iPoint, 0, nRealPoints)
                blk.writeIF4(aChannel.realChannel[iPoint].avgPrice.valueOrNan());
        }

        if (aChannel.hasPriceForecastOverrides()) {
            blk.start(opEntryPriceForecast);
            blk.writeID(aChannel.priceForecastOverrides().size());
            aChannel.priceForecastOverrides().loop([&blk](size_t t, float v) {
                blk.writeID(t);
                blk.writeIF4(v);
            });
        }

        if (aChannel.hasProfit()) {
            blk.start(opEntryProfit);
            FOR_S(iPoint, 0, nRealPoints)
                blk.writeIF4(aChannel.realChannel[iPoint].profit.valueOrNan());
        }

        if (aChannel.hasImportedRevenue()) {
            blk.start(opChannelRevenue);
            for (size_t i = 0; i < nRealPoints; ++i) {
                blk.writeIF4(aChannel.realChannel[i].importedRevenue.valueOrNan());
            }
        }

        if (aChannel.hasImportedOutlier()) {
            blk.start(opImportedOutlier);
            FOR_S(iPoint, 0, nRealPoints)
                blk.writeBool(aChannel.realChannel[iPoint].outlier.isAutoEq(CheckboxState::CHECKED)
                );
        }

        if (const size_t nPairs = aChannel.nOverriddenOutlier()) {
            blk.start(opOverriddenOutlier);
            blk.writeIQ(nPairs);
            FOR_S(iPoint, 0, nRealPoints) {
                const auto outlier = aChannel.realChannel[iPoint].outlier;
                if (outlier.isOverridden()) {
                    blk.writeIQ(iPoint);
                    blk.writeBool(outlier.isActiveEq(CheckboxState::CHECKED));
                }
            }
        }

        /*
                if (aChannel.hasModel()) {
                #ifdef USE_V1_FORMAT
                    blk.startDir(dirEntryModels_v1);
                    if (pKnownRev.part >= 1.0f) {  // Write whole points only
                        const PKnownInfo& pki = aChannel.pKnownInfo;
                        if (pki.model) {
                            blk.startDir(dirEntryModel);
                            pre::writeModel(blk, pKnownRev.tInventory, *pki.model);
                            blk.endDir();
                        }
                }
                    blk.endDir();
                #else
                    blk.startDir(dirEntryModels_v2);
                    FOR_S (iPoint, 0, rev.size()) {
                        const PKnownLookup::Item& v = rev[iPoint];
                        const PKnownInfo& pki = entry.pKnownInfo[v.lookupIndex];
                        if (pki.model) {
                            blk.startDir(dirEntryModel);
                            pre::writeModel(blk, iPoint, *pki.model);
                            blk.endDir();
                        }
                    }
                    blk.endDir();
                #endif
                }
        */

        blk.startDir(dirEntryModels);
        FOR_S(iPoint, 0, nRealPoints) {
            const auto modelPtr = aChannel.realChannel[iPoint].model;
            if (modelPtr == nullptr) {
                continue;
            }
            const auto iLastPeriod = nRealPoints - 1;
            blk.startDir(dirEntryModel);
            // for backward compatibility
            // overrides from storage should be save to model at last period
            if (iPoint != iLastPeriod) {
                pre::writeModel(blk, iPoint, *aChannel.realChannel[iPoint].model);
            }
            else {
                pre::writeModel(
                    blk, iPoint, *aChannel.realChannel[iPoint].model,
                    getFirstPartyOverridesTable(aChannel.predictionOverridesStorage())
                );
            }
            blk.endDir();
        }
        blk.endDir();

        // deprecated since FEB 2024, stored in PromotionStorage on SalesProject level
        // left here for backward compatibility
        writePromotions(blk, aChannel);

        if (!aChannel.snailInfo.isEmpty()) {
            blk.start(opSnailChannelInfo);
            blk.writeIF8(aChannel.snailInfo.dayRevenue);
            blk.writeIF8(aChannel.snailInfo.dayProfit);
            blk.writeIF4(aChannel.snailInfo.daySales);
            // New snail
            blk.writeIF4(aChannel.snailInfo.dayPriceQty);
            blk.writeIF4(aChannel.snailInfo.prevPriceQty);
        }

        if (aChannel.topDownCoeff.isOverridden()) {
            blk.start(opTopDownCoeffOverride);
            blk.writeIF8(aChannel.topDownCoeff.overrideValue.activeValue(0));
        }

        blk.start(opPredictionOverridesStorage);
        overridesSaver.save(blk, aChannel.predictionOverridesStorage());
    }

    void writeCommonEntry(
        st::BlockWriter2& blk, const SalesEntry& entry, bool aRequireTrivial,
        PredictionOverridesSaver& overridesSaver
    )
    {
        writeInventory(blk, entry.entryInfo());

        // Old versions write 4 bytes
        // blk.writeID(0); //entry.latestOnOrder);     // latest on order

        if (auto notePtr = entry.notePtr()) {
            blk.startDir(dirEntryDirectNote);
            utils::saveCommon(*notePtr, blk);
            blk.endDir();
        }

        writeHierSets(blk, entry.owner(), entry, HierOps::DFLT);

        if (entry.entryInfo().auxFields.size() != 0) {
            blk.start(opItemAuxFields);
            for (auto& v : entry.entryInfo().auxFields)
                blk.writeIWstringD(v.autoValue);

            if (entry.entryInfo().isAuxOverridden()) {
                blk.start(opItemAuxFieldsOverride);
                for (auto& v : entry.entryInfo().auxFields)
                    blk.writeIWstringD(v.overrideValue);
            }
        }

        const size_t nRealPoints = entry.owner().nRealPoints();
        const SalesChannel* trivialChannel = entry.trivialChannel();
        if (aRequireTrivial && !trivialChannel)
            throw UNEXPECTED_EXCEPTION("Wanted trivial channel.");

        if (trivialChannel) {
            writeChannelPart1(blk, *trivialChannel);
        }

        // Write arrivals/backorders
        writeInTransition(blk, entry);

        if (trivialChannel) {
            writeChannelPart2(blk, *trivialChannel);
        }

        blk.start(opEntryOnHand);
        FOR_S(iPoint, 0, nRealPoints)
            blk.writeID(entry.realInventory[iPoint].onHand.autoValue.rawValue());

        if (entry.isOnHandOverridden()) {
            blk.start(opEntryOnHandOverride);
            FOR_S(iPoint, 0, nRealPoints)
                blk.writeID(entry.realInventory[iPoint].onHand.overrideValue.rawValue());
        }

        if (entry.hasAvgOnHand()) {
            blk.start(opEntryAvgOnHand);
            FOR_S(iPoint, 0, nRealPoints)
                blk.writeIF4(entry.realInventory[iPoint].avgOnHand.valueOrNan());
        }

        // Misc. overrides (extend condition if smth new arrives)
        if (entry.safetyStockOverride.isSet()) {
            blk.blockOfID(opEntryMiscOverride, entry.safetyStockOverride.rawValue());
        }

        if (entry.lastArrivalPlaceDate.isValid()) {
            blk.start(opEntryLastPlace);
            st::writeDate(blk, entry.lastArrivalPlaceDate);
        }

        if (trivialChannel) {
            writeChannelPart3(blk, *trivialChannel);
        }

        if (entry.hasOnHandNotes()) {
            writePointNoteDir(
                blk, dirEntryOnHandNotes, entry.realInventory,
                [&entry](size_t i) -> const std::shared_ptr<Note>& {
                    return entry.realInventory[i].onHandNote;
                }
            );
        }

        if (trivialChannel)
            writeChannelPart4(blk, *trivialChannel, overridesSaver);
    }

    void writeExpirations(st::BlockWriter2& blk, const ExpirationData& expirationData)
    {
        blk.startDir(dirExpirations);
        for (auto& expiration : expirationData.expirations) {
            dt::Date expirationDate = expiration.first;
            for (auto& batch : expiration.second) {
                blk.startDir(dirExpiration);
                blk.start(opExpirationDate);
                st::writeDate(blk, expirationDate);
                blk.start(opBatchOnHand);
                blk.writeID(batch.onHand);
                blk.start(opBatchCode);
                blk.writeIWstringD(batch.batchCode);
                blk.endDir();
            }
        }
        blk.endDir();
    }

    void writeAutomationInfo(st::BlockWriter2& blk, const AutomationSettings& info)
    {
        st::writeEnum(blk, automationTypeNames[info.type]);
        st::writeTime(blk, info.previousTime);
        blk.writeID(info.period);
    }

    void writeCurvesEnable(
        st::BlockWriter2& blk, uint16_t aCode,
        const EcArray<bool, HideableCurveMeaning>& curveEnable
    )
    {
        blk.start(aCode);
        blk.writeIQ(curveEnable.Size);
        for (auto it = curveEnable.begin(); it < curveEnable.end(); ++it) {
            blk.writeBool(*it);
        }
    }

    void writeSeasonalityPatterns(st::BlockWriter2& blk, const SeasonalityPatternsMap& patterns)
    {
        if (patterns.empty())
            return;

        blk.startDir(dirSeasonalityPatterns);
        for (const auto& [id, pattern] : patterns) {
            blk.start(opSeasonalityPattern);
            blk.writeID(id);
            blk.writeIWstringD(pattern.name);
            blk.writeIF8(pattern.coeffs.fallbackLevel);
            blk.writeID(pattern.coeffs.seasonalCoeffs.size());

            for (const auto& coeff : pattern.coeffs.seasonalCoeffs) {
                blk.writeIF8(coeff);
            }
        }

        blk.endDir();
    }

    /// @brief used for build FilteredMap by filteredRootCat
    template <class SM, class Subcat, class FilteredMap>
    void buildMap(Subcat& aSubcat, FilteredMap& fMap)
    {
        aSubcat.allItemsT([&](AvailableItem<SM>& item) {
            fMap.addSecondary(item.sm.key(), item.sm);
        });
        // We just filter w/o changing → it’s perfectly possible to use
        // existing hierSource
        for (const auto& [name, subcatPtr] : aSubcat.subcats()) {
            auto& subMap = fMap.ensureSubcat(name);
            buildMap<SM>(*subcatPtr, subMap);
        }
    }

    template <class SM, class FilteredMap, class Subcat>
    FilteredMap buildMapRecurse(Subcat& aSubcat)
    {
        FilteredMap fMap;
        buildMap<SM>(aSubcat, fMap);
        return fMap;
    }

    using AvailableChannelCats = std::unordered_set<PCChannelCat>;

    void writeChannelCatsRecurse(
        st::BlockWriter2& blk, const HierSource& owner, const ChannelCat& cat,
        const AvailableChannelCats& availableCats, bool isRoot
    )
    {
        blk.startDir(dirChannelCats);
        if (cat.depth != 0) {
            blk.blockOfIWstringD(opChannelCatName, cat.name);
        }
        blk.blockOfID(opChannelCatId, cat.catId());
        if (!isRoot) {  // Root parasites on items’ root
            writeHierSetsInDir(blk, owner, cat, dirChannelHierSets);
        }
        blk.startDir(dirChannelSubcats);
        for (const auto& subcat : cat.subcats()) {
            if (availableCats.contains(subcat.toShared())) {
                writeChannelCatsRecurse(blk, owner, *subcat, availableCats, false);
            }
        }
        blk.endDir();  // dirChannelSubcats
        blk.endDir();  // dirChannelCats
    }

    void writeCatHeaders(st::BlockWriter2& blk, uint16_t opcode, Buf1d<const std::wstring> names)
    {
        if (names.size() != 0) {
            blk.start(opcode);
            blk.writeID(names.size());
            for (auto& v : names)
                blk.writeIWstringD(v);
        }
    }

    // clang-format off
    void writePromotionsStorage(st::BlockWriter2& blk, const PromotionsStorage& storage){
        blk.startDir(dirPromotionsStorage);
        storage.traverseAll([&](const Promotion& promoObj){
            blk.startDir(dirPromotionData);

                blk.startDir(dirPromotionInfo);
                    blk.start(opPromotionStart);
                    st::writeDate(blk, promoObj.info.startDate.autoValue);

                    if(promoObj.info.startDate.isOverridden()){
                        blk.start(opPromotionStart_override);
                        st::writeDate(blk, promoObj.info.startDate.activeOverrideValue(dt::Date::ZERO));
                    }

                    blk.start(opPromotionEnd);
                    st::writeDate(blk, promoObj.info.endDate.autoValue);

                    if(promoObj.info.endDate.isOverridden()){
                        blk.start(opPromotionEnd_override);
                        st::writeDate(blk, promoObj.info.endDate.activeOverrideValue(dt::Date::ZERO));
                    }

                    blk.start(opPromotionDiscount);
                    promoObj.info.discount.writeTo(blk);
                blk.endDir(); // dirPromotionInfo

                blk.blockOfIWstringD(opPromoItemCode, promoObj.channel.item);
                blk.blockOfIWstringD(opPromoLocation, promoObj.channel.location);
                blk.blockOfIWstringD(opPromoChannel, promoObj.channel.channel);

                blk.start(opPromoCreationType);
                st::writeEnum(blk, enumCode(promoObj.type));

            blk.endDir(); // dirPromotionData
        });
        blk.endDir(); // dirPromotionsStorage
    }

    // clang-format on

    void writeHistoricalOnHandStorage(st::BlockWriter2& blk, const HistoricalOnHandStorage& storage)
    {
        blk.startDir(dirHistoricalOnHandStorage);

        for (const auto& [entity, onHandinfo] : storage.internalDataForSave()) {
            blk.startDir(dirHistoricalOnHandInfo);
            blk.start(opEntityInfo);
            blk.writeIWstringD(entity.item);
            blk.writeIWstringD(entity.location);
            st::writeDate(blk, onHandinfo.lastUpdateDate());

            for (const auto& [date, onHand] : onHandinfo.points()) {
                blk.start(opHistoricalOnHandPoint);
                st::writeDate(blk, date);
                blk.writeID(onHand);
            }
            blk.endDir();  // dirHistoricalOnHandInfo
        }

        blk.endDir();  // dirHistoricalOnHandStorage
    }

}  // namespace

enum class AccessEntitiesType : uint32_t {
    NONE,
    EVERYONE,
    SPECIFIC_USERS,

    NN
};

constexpr auto accessEntitiesTypeCodes = EcArray<Char4, AccessEntitiesType>{
    kv<AccessEntitiesType::NONE>("NONE"), kv<AccessEntitiesType::EVERYONE>("EVON"),
    kv<AccessEntitiesType::SPECIFIC_USERS>("SPUS")
};

USE_ENUM_CODES(AccessEntitiesType, accessEntitiesTypeCodes)

namespace {

    void writeAccessEntities(st::BlockWriter2& blk, const AccessEntities& entities)
    {
        blk.startDir(dirAccessEntities);
        std::visit(
            utils::Overloaded{
                [&blk](AccessEntities::None) {
                    blk.start(opAccessEntitiesType);
                    st::writeEnum(blk, enumCode(AccessEntitiesType::NONE));
                },
                [&blk](AccessEntities::Everyone) {
                    blk.start(opAccessEntitiesType);
                    st::writeEnum(blk, enumCode(AccessEntitiesType::EVERYONE));
                },
                [&blk](const AccessEntities::UsersAndRoles& entities) {
                    blk.start(opAccessEntitiesType);
                    st::writeEnum(blk, enumCode(AccessEntitiesType::SPECIFIC_USERS));
                    blk.startDir(dirUsers);
                    for (const auto& userId : entities.users) {
                        blk.startDir(dirUser);
                        blk.blockOfStringD(opUserId, userId.string());
                        blk.endDir();
                    }
                    blk.endDir();

                    blk.startDir(dirRoles);
                    for (const auto& roleId : entities.roles) {
                        blk.startDir(dirRoleData);
                        blk.blockOfID(opRoleId, roleId);
                        blk.endDir();
                    }
                    blk.endDir();
                }
            },
            entities.get()
        );
        blk.endDir();
    }

    void writeStatisticalForecastPermittedUsers(
        st::BlockWriter2& blk, const StatisticalForecastPermittedUsers& permittedUsers
    )
    {
        blk.startDir(dirPermittedUsers);
        writeAccessEntities(blk, permittedUsers.viewers());
        blk.endDir();
    }

    void writePermittedUsers(st::BlockWriter2& blk, const PermittedUsers& permittedUsers)
    {
        blk.startDir(dirPermittedUsers);
        writeAccessEntities(blk, permittedUsers.viewers());
        writeAccessEntities(blk, permittedUsers.editors());
        blk.endDir();
    }

    void writeSetItemLoc(st::BlockWriter2& blk, uint16_t opcode, const CubeId::Coord& coord)
    {
        blk.startDir(opcode);
        switch (toUnderlying(coord)) {
        case CoordVar::ALL: blk.emptyBlock(opEphemeralAll); break;
        case CoordVar::CATEGORY: blk.blockOfIQ(opEphemeralCategory, std::get<size_t>(coord)); break;
        case CoordVar::LEAF:
            blk.blockOfIWstringD(opEphemeralLeaf, std::get<std::wstring>(coord));
            break;
        }
        blk.endDir();
    }

    void writeSetChannelAvatar(st::BlockWriter2& blk, const CubeId::ChannelAvatarCoord& coord)
    {
        blk.startDir(dirEphemeralSetChannel);
        switch (toUnderlying(coord)) {
        case ChannelAvatarVar::ALL:
        case ChannelAvatarVar::BAD:  // should not happen
            blk.emptyBlock(opEphemeralAll);
            break;
        case ChannelAvatarVar::CATEGORY:
            blk.blockOfIQ(opEphemeralCategory, std::get<size_t>(coord));
            break;
        case ChannelAvatarVar::AVATAR: {
            auto& av = std::get<CubeId::Avatar>(coord);
            blk.start(opEphemeralChannelAvatar);
            blk.writeIQ(av.catId);
            blk.writeIWstringD(av.channel);
        } break;
        }
        blk.endDir();
    }

    void writeEphemeral(st::BlockWriter2& blk, const CubeStorage& cube)
    {
        blk.startDir(dirEphemeral);
        // That’s default cube ID
        CubeId lastCubeId = CubeId::all();  // This object is physical, so never all three missing
        cube.hierEnumNonEmptyT([&](const CubeId& cubeId, const HierSettings& sets) {
            if (cubeId.thingType() == ThingType::EPHEMERAL) {
                blk.startDir(dirEphemeralObject);
                if (lastCubeId.item != cubeId.item) {
                    writeSetItemLoc(blk, dirEphemeralSetItem, cubeId.item);
                    lastCubeId.item = cubeId.item;
                }
                if (lastCubeId.location != cubeId.location) {
                    writeSetItemLoc(blk, dirEphemeralSetLocation, cubeId.location);
                    lastCubeId.location = cubeId.location;
                }
                if (lastCubeId.channelAvatar != cubeId.channelAvatar) {
                    writeSetChannelAvatar(blk, cubeId.channelAvatar);
                    lastCubeId.channelAvatar = cubeId.channelAvatar;
                }
                blk.startDir(dirEphemeralSettings);
                /// @todo [cubeId, future] NORMAL due to physical objects only
                doWriteHierSets(blk, sets, UseModelFromState::NORMAL, HierOps::DFLT);
                blk.endDir();
                blk.endDir();
            }
        });
        blk.endDir();
    }

}  // namespace

